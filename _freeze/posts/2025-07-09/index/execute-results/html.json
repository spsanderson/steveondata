{
  "hash": "7595dd32d15a0b83a0ba68ba764e250a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Pattern Matching with Regular Expressions in Python: A Beginner's Guide\"\nauthor: \"Steven P. Sanderson II, MPH\"\ndate: \"2025-07-09\"\ncategories: [code, python]\ntoc: TRUE\ndescription: \"Learn how to use regular expressions in Python to solve real-world text processing problems. This beginner-friendly guide covers the basics, practical examples, and common patterns.\"\nkeywords: [Programming, regex, regular expressions, python regex, pattern matching python, python regex tutorial, regex basics for beginners, python regex examples, how to use regular expressions in python, regex pattern matching techniques, python re module guide, how to perform pattern matching with regex in python, beginner-friendly python regex pattern matching tutorial, step-by-step guide to python regular expressions for beginners, using python regex to find phone numbers and emails, understanding regex syntax and pattern matching in python]\n---\n\n\n\n> **Author's Note:** I'm learning about regular expressions alongside you as I write this series. While I've done my research and tested the examples, there might be mistakes or oversights. If you spot any errors or have suggestions for improvement, please let me know! We're all learning together. ðŸŒ±\n\n# **Introduction**\n\nEver wished you could find all phone numbers in a document with just one line of code? Or validate email addresses without writing dozens of if-statements? That's where **regular expressions** (regex) come in handy!\n\nThink of regex as a super-powered search tool. Instead of looking for exact text like \"cat\", you can search for patterns like \"any three-letter word ending in 'at'\". In Python, the `re` module gives you access to this powerful pattern-matching capability .\n\nIn this guide, we'll explore how to use **Python regex** to solve real-world text processing problems. You'll learn the basics, see practical examples, and even try your hand at writing your own patterns.\n\n# **What Are Regular Expressions?**\n\nRegular expressions are special text patterns that describe how to search for text. They're like wildcards on steroids. While a simple search finds exact matches, regex can find patterns like:\n\n-   All words starting with \"Python\"\n-   Phone numbers in any format\n-   Email addresses\n-   Dates in MM/DD/YYYY format\n\nHere's a simple example:\n\n\n\n::: {.cell warnins='false'}\n::: {.cell-output .cell-output-stdout}\n\n```\nexit\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nimport re\n\ntext = \"My phone number is 415-555-1234\"\npattern = r'\\d{3}-\\d{3}-\\d{4}'\nmatch = re.search(pattern, text)\nif match:\n    print(f\"Found: {match.group()}\")  # Output: Found: 415-555-1234\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFound: 415-555-1234\n```\n\n\n:::\n:::\n\n\n\nThe pattern `\\d{3}-\\d{3}-\\d{4}` means \"three digits, dash, three digits, dash, four digits\" .\n\n# **Setting Up: The re Module**\n\nBefore using regex in Python, you need to import the `re` module:\n\n```python\nimport re\n```\n\nPython's `re` module provides several functions for pattern matching :\n\n| Function       | What It Does                                             |\n|------------------------------|------------------------------------------|\n| `re.search()`  | Finds the first match anywhere in the string             |\n| `re.match()`   | Checks if the pattern matches at the start of the string |\n| `re.findall()` | Returns all matches as a list                            |\n| `re.sub()`     | Replaces matches with new text                           |\n\n# **Basic Pattern Elements**\n\nLet's start with the building blocks of regex patterns:\n\n## **Character Classes**\n\nThese are shortcuts for common character types:\n\n-   `\\d` - Any digit (0-9)\n-   `\\w` - Any word character (letters, digits, underscore)\n-   `\\s` - Any whitespace (space, tab, newline)\n-   `.` - Any character except newline\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Finding all digits in a string\ntext = \"I have 2 cats and 3 dogs\"\ndigits = re.findall(r'\\d', text)\nprint(digits)  # Output: ['2', '3']\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n['2', '3']\n```\n\n\n:::\n:::\n\n\n\n## **Quantifiers**\n\nThese specify how many times a pattern should repeat:\n\n-   `*` - Zero or more times\n-   `+` - One or more times\n-   `?` - Zero or one time\n-   `{n}` - Exactly n times\n-   `{n,m}` - Between n and m times\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Finding words with 3 or more letters\ntext = \"I am learning Python\"\nlong_words = re.findall(r'\\w{3,}', text)\nprint(long_words)  # Output: ['learning', 'Python']\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n['learning', 'Python']\n```\n\n\n:::\n:::\n\n\n\n# **Common Regex Patterns for Beginners**\n\n## **1. Email Validation**\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef is_valid_email(email):\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return re.match(pattern, email) is not None\n\n# Test it\nprint(is_valid_email(\"user@example.com\"))  # True\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTrue\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(is_valid_email(\"invalid.email\"))     # False\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFalse\n```\n\n\n:::\n:::\n\n\n\n## **2. Phone Number Extraction**\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ntext = \"Call me at 415-555-1234 or (555) 987-6543\"\npattern = r'(\\(?\\d{3}\\)?[-.\\s]?\\d{3}[-.\\s]?\\d{4})'\nphones = re.findall(pattern, text)\nprint(phones)  # ['415-555-1234', '(555) 987-6543']\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n['415-555-1234', '(555) 987-6543']\n```\n\n\n:::\n:::\n\n\n\n## **3. Password Strength Check**\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef check_password(password):\n    # At least 8 chars, one uppercase, one lowercase, one digit\n    if len(password) < 8:\n        return False\n    if not re.search(r'[A-Z]', password):\n        return False\n    if not re.search(r'[a-z]', password):\n        return False\n    if not re.search(r'\\d', password):\n        return False\n    return True\n\nprint(check_password(\"Pass123!\"))  # True\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTrue\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(check_password(\"weak\"))      # False\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFalse\n```\n\n\n:::\n:::\n\n\n\n# **Groups: Extracting Parts of Matches**\n\nGroups let you extract specific parts of a match using parentheses:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Extract area code and number separately\nphone = \"415-555-1234\"\npattern = r'(\\d{3})-(\\d{3}-\\d{4})'\nmatch = re.search(pattern, phone)\nif match:\n    print(f\"Area code: {match.group(1)}\")  # 415\n    print(f\"Number: {match.group(2)}\")     # 555-1234\n    print(f\"Full match: {match.group(0)}\")  # 415-555-1234\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nArea code: 415\nNumber: 555-1234\nFull match: 415-555-1234\n```\n\n\n:::\n:::\n\n\n\n> **Remember:** `group(0)` is the entire match, `group(1)` is the first set of parentheses, and so on .\n\n# **Special Characters and Escaping**\n\nSome characters have special meanings in regex. To match them literally, you need to escape them with a backslash:\n\n| Character | Special Meaning | To Match Literally |\n|-----------|-----------------|--------------------|\n| `.`       | Any character   | `\\.`               |\n| `*`       | Zero or more    | `\\*`               |\n| `+`       | One or more     | `\\+`               |\n| `?`       | Zero or one     | `\\?`               |\n| `^`       | Start of string | `\\^`               |\n| `$`       | End of string   | `\\$`               |\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Matching a literal period\ntext = \"The price is $19.99\"\npattern = r'\\$\\d+\\.\\d{2}'\nmatch = re.search(pattern, text)\nprint(match.group())  # $19.99\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$19.99\n```\n\n\n:::\n:::\n\n\n\n# **Using Raw Strings (Important!)**\n\nAlways use raw strings (prefix with `r`) for regex patterns :\n\n```python\n# Good - raw string\npattern = r'\\d+'\n\n# Bad - regular string (backslash might be interpreted)\npattern = '\\d+'\n```\n\nRaw strings prevent Python from interpreting backslashes as escape characters.\n\n# **Common Mistakes to Avoid**\n\n## **1. Greedy vs. Non-Greedy Matching**\n\nBy default, quantifiers are \"greedy\" - they match as much as possible:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ntext = '<b>Bold</b> and <i>Italic</i>'\n# Greedy - matches too much!\ngreedy = re.findall(r'<.*>', text)\nprint(greedy)  # ['<b>Bold</b> and <i>Italic</i>']\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n['<b>Bold</b> and <i>Italic</i>']\n```\n\n\n:::\n\n```{.python .cell-code}\n# Non-greedy - add ? after quantifier\nnon_greedy = re.findall(r'<.*?>', text)\nprint(non_greedy)  # ['<b>', '</b>', '<i>', '</i>']\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n['<b>', '</b>', '<i>', '</i>']\n```\n\n\n:::\n:::\n\n\n\n## **2. Forgetting Anchors**\n\nUse `^` and `$` to match the entire string:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Without anchors - matches partial string\npattern = r'\\d{3}'\nprint(re.search(pattern, \"abc123def\"))  # Matches!\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<re.Match object; span=(3, 6), match='123'>\n```\n\n\n:::\n\n```{.python .cell-code}\n# With anchors - must be entire string\npattern = r'^\\d{3}$'\nprint(re.search(pattern, \"abc123def\"))  # No match\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNone\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(re.search(pattern, \"123\"))        # Matches!\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<re.Match object; span=(0, 3), match='123'>\n```\n\n\n:::\n:::\n\n\n\n## **3. Case Sensitivity**\n\nRegex is case-sensitive by default. Use the `re.IGNORECASE` flag for case-insensitive matching :\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ntext = \"Python PYTHON python\"\n# Case-sensitive\nprint(re.findall(r'python', text))  # ['python']\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n['python']\n```\n\n\n:::\n\n```{.python .cell-code}\n# Case-insensitive\nprint(re.findall(r'python', text, re.IGNORECASE))  # ['Python', 'PYTHON', 'python']\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n['Python', 'PYTHON', 'python']\n```\n\n\n:::\n:::\n\n\n\n# **Your Turn!**\n\nHere's a practical exercise to test your new regex skills:\n\n**Challenge:** Write a regex pattern to find all dates in the format MM/DD/YYYY in the following text:\n\n```python\ntext = \"\"\"\nImportant dates:\n- Project starts on 01/15/2025\n- First deadline: 02/28/2025\n- Final submission: 12/31/2025\n- Invalid date: 13/45/2025\n\"\"\"\n\n# Write your pattern here\npattern = r'___'  # Fill in the blank!\n\ndates = re.findall(pattern, text)\nprint(dates)\n```\n\n<details>\n<summary>Click here for Solution!</summary>\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ntext = \"\"\"\nImportant dates:\n- Project starts on 01/15/2025\n- First deadline: 02/28/2025\n- Final submission: 12/31/2025\n- Invalid date: 13/45/2025\n\"\"\"\n\n# Solution\npattern = r'\\b(0[1-9]|1[0-2])/(0[1-9]|[12][0-9]|3[01])/\\d{4}\\b'\n\ndates = re.findall(pattern, text)\nprint(dates)  # [('01', '15'), ('02', '28'), ('12', '31')]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[('01', '15'), ('02', '28'), ('12', '31')]\n```\n\n\n:::\n\n```{.python .cell-code}\n# To get full dates as strings:\npattern = r'\\b(?:0[1-9]|1[0-2])/(?:0[1-9]|[12][0-9]|3[01])/\\d{4}\\b'\ndates = re.findall(pattern, text)\nprint(dates)  # ['01/15/2025', '02/28/2025', '12/31/2025']\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n['01/15/2025', '02/28/2025', '12/31/2025']\n```\n\n\n:::\n:::\n\n\n\nThe pattern breaks down as: - `\\b` - Word boundary - `(?:0[1-9]|1[0-2])` - Month: 01-09 or 10-12 - `/` - Literal forward slash - `(?:0[1-9]|[12][0-9]|3[01])` - Day: 01-09, 10-29, or 30-31 - `/` - Another forward slash - `\\d{4}` - Four-digit year - `\\b` - Word boundary\n\nNote: This pattern doesn't validate if dates are real (like February 30th).\n\n</details>\n\n# **Quick Reference Guide**\n\n## **Common Patterns**\n\n```python\n# Email\nemail_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n\n# Phone (US format)\nphone_pattern = r'(\\(?\\d{3}\\)?[-.\\s]?\\d{3}[-.\\s]?\\d{4})'\n\n# URL\nurl_pattern = r'https?://(?:www\\.)?[\\w.-]+(?:\\.[\\w\\.-]+)+[\\w\\-\\._~:/?#[\\]@!\\$&\\'\\(\\)\\*\\+,;=.]+'\n\n# Date (MM/DD/YYYY)\ndate_pattern = r'\\b(?:0[1-9]|1[0-2])/(?:0[1-9]|[12][0-9]|3[01])/\\d{4}\\b'\n```\n\n## **Most Used Functions**\n\n```python\n# Search for first match\nmatch = re.search(pattern, text)\nif match:\n    result = match.group()\n\n# Find all matches\nmatches = re.findall(pattern, text)\n\n# Replace matches\nnew_text = re.sub(pattern, replacement, text)\n\n# Split by pattern\nparts = re.split(pattern, text)\n```\n\n# **Key Takeaways**\n\n-   **Always use raw strings** (r'pattern') for regex patterns\n-   **Start simple** - build complex patterns step by step\n-   **Test your patterns** with online tools like regex101.com\n-   **Remember the difference** between search(), match(), and findall()\n-   **Escape special characters** when you want to match them literally\n-   **Use groups** to extract parts of your matches\n-   **Be careful with greedy matching** - add ? to make quantifiers non-greedy\n\n# **Conclusion**\n\nRegular expressions might seem intimidating at first, but they're just patterns made up of simple building blocks. Start with basic patterns like `\\d+` for numbers or `\\w+` for words, then gradually combine them to solve more complex problems.\n\nThe key is practice! Try modifying the examples in this guide, experiment with your own patterns, and don't be afraid to make mistakes. Every Python programmer started exactly where you are now.\n\n**Ready to level up your text processing skills?** Pick a real problem you're facing - maybe cleaning up messy data or validating user input - and try solving it with regex. You'll be surprised how much time it can save!\n\n# **Frequently Asked Questions**\n\n**Q: When should I use regex instead of regular string methods?** A: Use regex when you need pattern matching, not exact matching. For simple tasks like checking if a string starts with something, use `str.startswith()`. For complex patterns like \"find all email addresses,\" use regex.\n\n**Q: Why do my patterns sometimes not work?** A: Common issues include forgetting to use raw strings, not escaping special characters, or using greedy matching when you need non-greedy. Test your patterns piece by piece to find the problem.\n\n**Q: Are Python regex patterns the same as in other languages?** A: The basics are similar, but there are differences. Python uses Perl-compatible syntax with some variations. Always check Python-specific documentation .\n\n**Q: How can I make my regex patterns more readable?** A: Use the `re.VERBOSE` flag to write patterns across multiple lines with comments :\n\n```python\npattern = re.compile(r'''\n    \\d{3}  # Area code\n    -      # Separator\n    \\d{4}  # Number\n''', re.VERBOSE)\n```\n\n**Q: Is there a performance impact with complex regex?** A: Yes, poorly written patterns can be slow. The `re` module caches the last 512 compiled patterns for efficiency. For frequently used patterns, compile them once and reuse.\n\n# **Share Your Experience!**\n\nFound this guide helpful? Have questions or suggestions? I'd love to hear from you! Drop a comment below or share this article with fellow Python learners. Remember, we're all learning together, and your feedback helps make these guides better for everyone.\n\nFollow me for more beginner-friendly Python tutorials, and don't forget to bookmark this page for quick reference!\n\n# **References**\n\n1. [Python Software Foundation. \"re â€” Regular expression operations.\" Python Documentation.](https://docs.python.org/3/library/re.html)\n\n2. [Python Software Foundation. \"Regular Expression HOWTO.\" Python Documentation.](https://docs.python.org/3/howto/regex.html)\n\n3. [Real Python. \"Regular Expressions: Regexes in Python.\"](https://realpython.com/regex-python/)\n\n4. [Sweigart, Al. \"Automate the Boring Stuff with Python.\" Chapter 7: Pattern Matching with Regular Expressions.](https://automatetheboringstuff.com/2e/chapter7/)\n\n------------------------------------------------------------------------\n\nHappy Coding! ðŸš€\n\n![Regex in Python](todays_post.png)\n\n------------------------------------------------------------------------\n\n*You can connect with me at any one of the below*:\n\n*Telegram Channel here*: <https://t.me/steveondata>\n\n*LinkedIn Network here*: <https://www.linkedin.com/in/spsanderson/>\n\n*Mastadon Social here*: [https://mstdn.social/\\@stevensanderson](https://mstdn.social/@stevensanderson)\n\n*RStats Network here*: [https://rstats.me/\\@spsanderson](https://rstats.me/@spsanderson)\n\n*GitHub Network here*: <https://github.com/spsanderson>\n\n*Bluesky Network here*: <https://bsky.app/profile/spsanderson.com>\n\n*My Book: Extending Excel with Python and R* here: <https://packt.link/oTyZJ>\n\n*You.com Referral Link*: <https://you.com/join/EHSLDTL6>\n\n------------------------------------------------------------------------\n\n\n\n```{=html}\n<script src=\"https://giscus.app/client.js\"\n        data-repo=\"spsanderson/steveondata\"\n        data-repo-id=\"R_kgDOIIxnLw\"\n        data-category=\"Comments\"\n        data-category-id=\"DIC_kwDOIIxnL84ChTk8\"\n        data-mapping=\"url\"\n        data-strict=\"0\"\n        data-reactions-enabled=\"1\"\n        data-emit-metadata=\"0\"\n        data-input-position=\"top\"\n        data-theme=\"dark\"\n        data-lang=\"en\"\n        data-loading=\"lazy\"\n        crossorigin=\"anonymous\"\n        async>\n</script>\n```\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}