{
  "hash": "fb2efab22425b6465e842887d17fc0e7",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"How to Add a Total Row to a Data Frame in R: Complete Guide for R Programmers\"\nauthor: \"Steven P. Sanderson II, MPH\"\ndate: \"2025-07-28\"\ncategories: [code, rtip]\ntoc: TRUE\ndescription: \"Learn how to add total rows in R using Base R, dplyr, and data.table. Complete guide with syntax explanations, code examples, and performance comparisons.\"\nkeywords: [Programming, add total row in R, total row using dplyr, total row using data.table, R data frame total row, sum row in R, R data frame summary, dplyr summarise total, data.table summary row, R column sums, append row to data frame R, how to add a total row to a data frame in R using dplyr, create a summary row in R data frame with data.table, best way to add grand total row in R, add sum row to R data frame without packages, performance comparison of total row methods in R]\n---\n\n\n\nAdding a **total row in R** is one of those everyday tasks that an analyst encounters when creating reports or analyzing data. Whether you're summarizing sales figures, calculating budget totals, or creating financial statements, knowing how to efficiently add total rows to your data frames can be helpful.\n\nIn this comprehensive guide, we'll explore three different approaches to adding total rows: using Base R, the popular dplyr package, and the lightning-fast data.table package. We'll break down the syntax in simple terms, provide practical examples, and even compare their performance to help you choose the best method for your needs.\n\n> **Key Insight:** While adding total rows might seem simple, choosing the right method can significantly impact your code's readability and performance, especially with large datasets.\n\n---\n\n# Why Add Total Rows to Data Frames?\n\nBefore jumping into the code, let's understand when and why you might need to add total rows:\n\n## Common Use Cases\n\n1. **Financial Reports** \n   - Income statements showing total revenue\n   - Expense reports with grand totals\n   - Budget summaries with category totals\n\n2. **Data Validation** \n   - Verifying calculations are correct\n   - Cross-checking subtotals\n   - Quality control in data entry\n\n3. **Business Analytics**\n   - Sales reports by region or product\n   - Inventory summaries\n   - Performance metrics dashboards\n\n4. **Academic Research**\n   - Survey response summaries\n   - Experimental data totals\n   - Statistical report tables\n\n# Method 1: Adding Total Rows Using Base R\n\nBase R provides the most straightforward approach using built-in functions. This method requires no additional packages and works well for simple cases.\n\n## The Basic Syntax\n\n```r\n# Step 1: Calculate column sums\ntotals <- colSums(df[, numeric_columns], na.rm = TRUE)\n\n# Step 2: Create the total row\ntotal_row <- data.frame(t(totals))\n\n# Step 3: Add the total row\ndf_with_total <- rbind(df, total_row)\n```\n\n## Complete Example\n\nLet's create a simple sales data frame and add a total row:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create sample data\nsales_data <- data.frame(\n  Product = c(\"Laptop\", \"Mouse\", \"Keyboard\"),\n  Q1_Sales = c(15000, 2500, 3500),\n  Q2_Sales = c(18000, 3000, 4000),\n  Q3_Sales = c(20000, 2800, 3800)\n)\n\n# Display original data\nprint(sales_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Product Q1_Sales Q2_Sales Q3_Sales\n1   Laptop    15000    18000    20000\n2    Mouse     2500     3000     2800\n3 Keyboard     3500     4000     3800\n```\n\n\n:::\n\n```{.r .cell-code}\n# Calculate totals for numeric columns\nnumeric_cols <- c(\"Q1_Sales\", \"Q2_Sales\", \"Q3_Sales\")\ntotals <- colSums(sales_data[, numeric_cols])\n\n# Create total row\ntotal_row <- data.frame(\n  Product = \"Total\",\n  t(totals)\n)\n\n# Add total row\nsales_with_total <- rbind(sales_data, total_row)\nprint(sales_with_total)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Product Q1_Sales Q2_Sales Q3_Sales\n1   Laptop    15000    18000    20000\n2    Mouse     2500     3000     2800\n3 Keyboard     3500     4000     3800\n4    Total    21000    25000    26600\n```\n\n\n:::\n:::\n\n\n\n## Handling Mixed Data Types\n\nWhen your data frame has both numeric and non-numeric columns, you need to be more careful:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# More complex example with mixed types\ncompany_data <- data.frame(\n  Department = c(\"Sales\", \"Marketing\", \"IT\"),\n  Manager = c(\"John\", \"Sarah\", \"Mike\"),\n  Employees = c(25, 15, 10),\n  Budget = c(500000, 300000, 400000),\n  stringsAsFactors = FALSE\n)\n\n# Identify numeric columns automatically\nnumeric_columns <- sapply(company_data, is.numeric)\nnumeric_col_names <- names(company_data)[numeric_columns]\n\n# Calculate totals only for numeric columns\ntotals <- colSums(company_data[, numeric_col_names])\n\n# Create total row with proper structure\ntotal_row <- company_data[1, ]  # Copy structure\ntotal_row[1, ] <- NA            # Clear all values\ntotal_row$Department <- \"Total\"\ntotal_row$Manager <- \"-\"\ntotal_row[, numeric_col_names] <- totals\n\n# Combine original data with total row\ncompany_with_total <- rbind(company_data, total_row)\nprint(company_with_total)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Department Manager Employees  Budget\n1      Sales    John        25  500000\n2  Marketing   Sarah        15  300000\n3         IT    Mike        10  400000\n4      Total       -        50 1200000\n```\n\n\n:::\n:::\n\n\n\n# Method 2: Adding Total Rows Using dplyr\n\nThe **total row using dplyr** approach offers a more modern, pipeline-friendly syntax that many R programmers prefer .\n\n## The dplyr Syntax\n\n```r\nlibrary(dplyr)\n\ndf_with_total <- df %>%\n  bind_rows(\n    summarise(., \n      across(where(is.numeric), sum),\n      across(where(is.character), ~\"Total\")\n    )\n  )\n```\n\n## Complete dplyr Example\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\n# Using the same sales data\nsales_data <- data.frame(\n  Product = c(\"Laptop\", \"Mouse\", \"Keyboard\"),\n  Q1_Sales = c(15000, 2500, 3500),\n  Q2_Sales = c(18000, 3000, 4000),\n  Q3_Sales = c(20000, 2800, 3800)\n)\n\n# Add total row using dplyr\nsales_with_total <- sales_data %>%\n  bind_rows(\n    summarise(.,\n      Product = \"Total\",\n      across(where(is.numeric), sum)\n    )\n  )\n\nprint(sales_with_total)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Product Q1_Sales Q2_Sales Q3_Sales\n1   Laptop    15000    18000    20000\n2    Mouse     2500     3000     2800\n3 Keyboard     3500     4000     3800\n4    Total    21000    25000    26600\n```\n\n\n:::\n:::\n\n\n\n## Advanced dplyr Techniques\n\n### Adding Subtotals and Grand Total\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create data with categories\ndetailed_sales <- data.frame(\n  Category = c(\"Electronics\", \"Electronics\", \"Office\", \"Office\"),\n  Product = c(\"Laptop\", \"Mouse\", \"Desk\", \"Chair\"),\n  Q1_Sales = c(15000, 2500, 8000, 6000),\n  Q2_Sales = c(18000, 3000, 9000, 7000)\n)\n\n# Add category subtotals and grand total\nsales_with_all_totals <- detailed_sales %>%\n  # Add category subtotals\n  group_by(Category) %>%\n  summarise(\n    Product = \"Subtotal\",\n    across(where(is.numeric), sum)\n  ) %>%\n  # Combine with original data\n  bind_rows(detailed_sales, .) %>%\n  # Add grand total\n  bind_rows(\n    summarise(detailed_sales,\n      Category = \"Grand Total\",\n      Product = \"-\",\n      across(where(is.numeric), sum)\n    )\n  ) %>%\n  arrange(Category, Product)\n\nprint(sales_with_all_totals)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Category  Product Q1_Sales Q2_Sales\n1 Electronics   Laptop    15000    18000\n2 Electronics    Mouse     2500     3000\n3 Electronics Subtotal    17500    21000\n4 Grand Total        -    31500    37000\n5      Office    Chair     6000     7000\n6      Office     Desk     8000     9000\n7      Office Subtotal    14000    16000\n```\n\n\n:::\n:::\n\n\n\n### Using Custom Summary Functions\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Add multiple summary rows (total, mean, max)\nsales_summary <- sales_data %>%\n  bind_rows(\n    # Total row\n    summarise(.,\n      Product = \"Total\",\n      across(where(is.numeric), sum)\n    ),\n    # Average row\n    summarise(.,\n      Product = \"Average\",\n      across(where(is.numeric), mean)\n    ),\n    # Maximum row\n    summarise(.,\n      Product = \"Maximum\",\n      across(where(is.numeric), max)\n    )\n  )\n\nprint(sales_summary)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Product Q1_Sales  Q2_Sales  Q3_Sales\n1   Laptop    15000 18000.000 20000.000\n2    Mouse     2500  3000.000  2800.000\n3 Keyboard     3500  4000.000  3800.000\n4    Total    21000 25000.000 26600.000\n5  Average     7000  8333.333  8866.667\n6  Maximum    15000 18000.000 20000.000\n```\n\n\n:::\n:::\n\n\n\n# Method 3: Adding Total Rows Using data.table\n\nThe **total row using data.table** method provides the best performance for large datasets .\n\n## The data.table Syntax\n\n```r\nlibrary(data.table)\n\n# Convert to data.table\ndt <- as.data.table(df)\n\n# Add total row\ndt_with_total <- rbindlist(list(\n  dt,\n  dt[, lapply(.SD, sum), .SDcols = numeric_cols][, Category := \"Total\"]\n))\n```\n\n## Complete data.table Example\n\n\n\n::: {.cell messge='false'}\n\n```{.r .cell-code}\nlibrary(data.table)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'data.table'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:dplyr':\n\n    between, first, last\n```\n\n\n:::\n\n```{.r .cell-code}\n# Create data.table\nsales_dt <- data.table(\n  Product = c(\"Laptop\", \"Mouse\", \"Keyboard\"),\n  Q1_Sales = c(15000, 2500, 3500),\n  Q2_Sales = c(18000, 3000, 4000),\n  Q3_Sales = c(20000, 2800, 3800)\n)\n\n# Identify numeric columns\nnum_cols <- names(sales_dt)[sapply(sales_dt, is.numeric)]\n\n# Create total row\ntotal_row <- sales_dt[, lapply(.SD, sum), .SDcols = num_cols]\ntotal_row[, Product := \"Total\"]\nsetcolorder(total_row, names(sales_dt))\n\n# Combine with original data\nsales_with_total <- rbindlist(list(sales_dt, total_row))\nprint(sales_with_total)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    Product Q1_Sales Q2_Sales Q3_Sales\n     <char>    <num>    <num>    <num>\n1:   Laptop    15000    18000    20000\n2:    Mouse     2500     3000     2800\n3: Keyboard     3500     4000     3800\n4:    Total    21000    25000    26600\n```\n\n\n:::\n:::\n\n\n\n## Advanced data.table Techniques\n\n### Group-wise Totals\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Data with groups\ngrouped_dt <- data.table(\n  Region = c(\"North\", \"North\", \"South\", \"South\", \"East\", \"East\"),\n  Product = c(\"A\", \"B\", \"A\", \"B\", \"A\", \"B\"),\n  Sales = c(100, 200, 150, 250, 120, 180),\n  Units = c(10, 20, 15, 25, 12, 18)\n)\n\n# Add regional totals\nregional_totals <- grouped_dt[, \n  .(Product = \"Regional Total\", \n    Sales = sum(Sales), \n    Units = sum(Units)), \n  by = Region\n]\n\n# Add grand total\ngrand_total <- grouped_dt[, \n  .(Region = \"Grand Total\",\n    Product = \"-\", \n    Sales = sum(Sales), \n    Units = sum(Units))\n]\n\n# Combine all\ncomplete_dt <- rbindlist(list(grouped_dt, regional_totals, grand_total))\nsetorder(complete_dt, Region, Product)\nprint(complete_dt)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         Region        Product Sales Units\n         <char>         <char> <num> <num>\n 1:        East              A   120    12\n 2:        East              B   180    18\n 3:        East Regional Total   300    30\n 4: Grand Total              -  1000   100\n 5:       North              A   100    10\n 6:       North              B   200    20\n 7:       North Regional Total   300    30\n 8:       South              A   150    15\n 9:       South              B   250    25\n10:       South Regional Total   400    40\n```\n\n\n:::\n:::\n\n\n\n# Performance Comparison Using the `rbenchmark` Package\n\nTo objectively compare the speed of adding a total row using **Base R**, **dplyr**, and **data.table**, we can use the [`rbenchmark`](https://cran.r-project.org/web/packages/rbenchmark/index.html) package. This package allows you to run each method multiple times and provides a summary of their execution times, making it easy to see which approach is fastest on your system.\n\nBelow is a reproducible example using a data frame with 10,000 rows and three numeric columns. We'll benchmark each method for adding a total row.\n\n\n\n::: {.cell messge='false'}\n\n```{.r .cell-code}\n# Install and load required packages\n#install.packages(c(\"dplyr\", \"data.table\", \"rbenchmark\"))\nlibrary(dplyr)\nlibrary(data.table)\nlibrary(rbenchmark)\n\n# Create a sample data frame\nset.seed(123)\nn <- 10000\ndf <- data.frame(\n  Product = sample(c(\"A\", \"B\", \"C\"), n, replace = TRUE),\n  Q1_Sales = sample(1000:5000, n, replace = TRUE),\n  Q2_Sales = sample(1000:5000, n, replace = TRUE),\n  Q3_Sales = sample(1000:5000, n, replace = TRUE),\n  stringsAsFactors = FALSE\n)\n\n# Base R method\nbase_r_total <- function() {\n  numeric_cols <- c(\"Q1_Sales\", \"Q2_Sales\", \"Q3_Sales\")\n  totals <- colSums(df[, numeric_cols])\n  total_row <- data.frame(Product = \"Total\", t(totals))\n  rbind(df, total_row)\n}\n\n# dplyr method\ndplyr_total <- function() {\n  df %>%\n    bind_rows(\n      summarise(.,\n        Product = \"Total\",\n        across(where(is.numeric), sum)\n      )\n    )\n}\n\n# data.table method\ndata_table_total <- function() {\n  dt <- as.data.table(df)\n  num_cols <- names(dt)[sapply(dt, is.numeric)]\n  total_row <- dt[, lapply(.SD, sum), .SDcols = num_cols]\n  total_row[, Product := \"Total\"]\n  setcolorder(total_row, names(dt))\n  rbindlist(list(dt, total_row))\n}\n\n# Benchmark all three methods\nbenchmark(\n  baseR = base_r_total(),\n  dplyr = dplyr_total(),\n  data_table = data_table_total(),\n  replications = 500,\n  columns = c(\"test\", \"replications\", \"elapsed\", \"relative\", \"user.self\", \"sys.self\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        test replications elapsed relative user.self sys.self\n1      baseR          500    0.57    1.000      0.53     0.03\n3 data_table          500    0.77    1.351      0.71     0.06\n2      dplyr          500    1.51    2.649      1.46     0.02\n```\n\n\n:::\n:::\n\n\n\n- **elapsed**: Total time taken (in seconds) for all replications.\n- **relative**: Time relative to the fastest method (lower is better).\n\n\n**Tip:** The `rbenchmark` package is a simple and effective way to compare the performance of different R code snippets, especially when you want to see clear timing differences between approaches.\n\n**Summary:**\n\n- Use `rbenchmark` to compare methods for adding total rows.\n- For large data, **dplyr** and **data.table** are generally faster than Base R.\n\n# Your Turn!\n\nNow it's time to practice what you've learned. Try solving this problem:\n\n**Challenge:** You have monthly expense data for different departments. Add a total row showing the sum of all expenses.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Given data\nexpenses <- data.frame(\n  Department = c(\"HR\", \"IT\", \"Sales\", \"Marketing\"),\n  Jan = c(5000, 8000, 12000, 6000),\n  Feb = c(5200, 7500, 13000, 6500),\n  Mar = c(4800, 8200, 11500, 7000)\n)\n\n# Your task: Add a total row using any method\n```\n:::\n\n\n\n<details><summary>Click here for Solution!</summary>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Solution using dplyr (recommended)\nlibrary(dplyr)\n\nexpenses_with_total <- expenses %>%\n  bind_rows(\n    summarise(.,\n      Department = \"Total\",\n      across(where(is.numeric), sum)\n    )\n  )\n\nprint(expenses_with_total)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Department   Jan   Feb   Mar\n1         HR  5000  5200  4800\n2         IT  8000  7500  8200\n3      Sales 12000 13000 11500\n4  Marketing  6000  6500  7000\n5      Total 31000 32200 31500\n```\n\n\n:::\n\n```{.r .cell-code}\n# Alternative: Base R solution\ntotals <- colSums(expenses[, -1])\ntotal_row <- data.frame(Department = \"Total\", t(totals))\nexpenses_with_total_base <- rbind(expenses, total_row)\n\n# Alternative: data.table solution\nlibrary(data.table)\nexpenses_dt <- as.data.table(expenses)\nnum_cols <- names(expenses_dt)[-1]\ntotal_row_dt <- expenses_dt[, lapply(.SD, sum), .SDcols = num_cols]\ntotal_row_dt[, Department := \"Total\"]\nsetcolorder(total_row_dt, names(expenses_dt))\nexpenses_with_total_dt <- rbindlist(list(expenses_dt, total_row_dt))\n```\n:::\n\n\n\n</details>\n\n# Quick Takeaways\n\n- **Base R** is best for simple cases and when avoiding dependencies\n- **dplyr** offers the cleanest syntax and best performance for most use cases  \n- **data.table** provides the best memory efficiency for very large datasets\n- Always identify numeric columns before calculating totals\n- Use `na.rm = TRUE` in sum functions to handle missing values\n- Consider adding multiple summary rows (totals, averages, etc.) for comprehensive reports\n\n# Best Practices and Tips\n\n## 1. Handle Missing Values Properly\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Always use na.rm = TRUE when calculating totals\ndf_with_na <- data.frame(\n  Category = c(\"A\", \"B\", \"C\"),\n  Value1 = c(100, NA, 300),\n  Value2 = c(50, 75, NA)\n)\n\n# Correct approach\ntotals <- colSums(df_with_na[, -1], na.rm = TRUE)\nprint(totals)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nValue1 Value2 \n   400    125 \n```\n\n\n:::\n:::\n\n\n\n## 2. Preserve Data Types\n\n```r\n# Ensure numeric columns stay numeric\ntotal_row <- df[1, ]  # Copy structure\ntotal_row[1, ] <- NA  # Clear values\n# Then fill in your totals\n```\n\n## 3. Format Numbers for Display\n\n```r\n# Format large numbers for readability\nlibrary(scales)\ndf_formatted <- df %>%\n  mutate(across(where(is.numeric), ~comma(.)))\n```\n\n## 4. Consider Tidy Data Principles\n\nRemember that adding total rows technically violates \"tidy data\" principles where each row should represent one observation. Consider whether you need the total row in your data or just in your final output/report.\n\n# Conclusion\n\nAdding a **total row in R** is a skill that every R programmer can master. We've explored three powerful methods:\n\n1. **Base R** - Simple and dependency-free\n2. **dplyr** - Modern, readable, and performant\n3. **data.table** - Fast and memory-efficient\n\nFor most R programmers, **dplyr provides the best balance** of readability, performance, and ease of use. However, don't overlook Base R for simple scripts or data.table when working with massive datasets.\n\n**Ready to level up your R skills?** Start practicing with your own datasets and experiment with combining these methods to create more complex summaries and reports!\n\n# Frequently Asked Questions (FAQs)\n\n**Q1: Can I add multiple total rows at once?**\nYes! You can add multiple summary rows (like totals, averages, and counts) by combining multiple `summarise()` calls in dplyr or creating multiple summary rows and using `rbind()` in Base R.\n\n**Q2: How do I add total rows to grouped data?**\nUse `group_by()` before `summarise()` in dplyr, or use the `by` parameter in data.table to create group-wise totals before adding a grand total.\n\n**Q3: What if my data has factor columns?**\nConvert factors to characters first using `as.character()`, or handle them separately when creating your total row to avoid factor level conflicts.\n\n**Q4: Is it better to add totals in R or in my reporting tool?**\nIt depends on your workflow. Adding totals in R ensures consistency across all outputs, while adding them in reporting tools (like Excel) keeps your data \"tidy.\"\n\n**Q5: How can I add row totals (sum across columns) instead of column totals?**\nUse `rowSums()` in Base R or `rowwise()` with `mutate()` in dplyr to calculate sums across columns for each row.\n\n# Engage!\n\nDid this guide help you master adding total rows in R? We'd love to hear about your use cases and any creative solutions you've developed! \n\nShare your thoughts in the comments below, or connect with us on social media. Don't forget to bookmark this guide for future reference and share it with fellow R programmers who might find it helpful!\n\n**Happy coding, and may your totals always add up! ðŸ“Š**\n\n# References\n\n- [dplyr: A Grammar of Data Manipulation (official documentation)](https://dplyr.tidyverse.org/) \n- [Introduction to data.table (official CRAN vignette)](https://cran.r-project.org/package=data.table/vignettes/datatable-intro.html) \n- [R Introduction Manual - Data manipulation (CRAN)](https://cran.r-project.org/doc/manuals/r-release/R-intro.html)\n- [Profiling and benchmarking - Advanced R by Hadley Wickham](https://adv-r.hadley.nz/perf-measure.html)\n\n------------------------------------------------------------------------\n\nHappy Coding! ðŸš€\n\n![Totals Rows in R](todays_post.png)\n\n------------------------------------------------------------------------\n\n*You can connect with me at any one of the below*:\n\n*Telegram Channel here*: <https://t.me/steveondata>\n\n*LinkedIn Network here*: <https://www.linkedin.com/in/spsanderson/>\n\n*Mastadon Social here*: [https://mstdn.social/\\@stevensanderson](https://mstdn.social/@stevensanderson)\n\n*RStats Network here*: [https://rstats.me/\\@spsanderson](https://rstats.me/@spsanderson)\n\n*GitHub Network here*: <https://github.com/spsanderson>\n\n*Bluesky Network here*: <https://bsky.app/profile/spsanderson.com>\n\n*My Book: Extending Excel with Python and R* here: <https://packt.link/oTyZJ>\n\n*You.com Referral Link*: <https://you.com/join/EHSLDTL6>\n\n------------------------------------------------------------------------\n\n\n\n```{=html}\n<script src=\"https://giscus.app/client.js\"\n        data-repo=\"spsanderson/steveondata\"\n        data-repo-id=\"R_kgDOIIxnLw\"\n        data-category=\"Comments\"\n        data-category-id=\"DIC_kwDOIIxnL84ChTk8\"\n        data-mapping=\"url\"\n        data-strict=\"0\"\n        data-reactions-enabled=\"1\"\n        data-emit-metadata=\"0\"\n        data-input-position=\"top\"\n        data-theme=\"dark\"\n        data-lang=\"en\"\n        data-loading=\"lazy\"\n        crossorigin=\"anonymous\"\n        async>\n</script>\n```\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}