{
  "hash": "030017eeef4067cd9a80615a73976fed",
  "result": {
    "markdown": "---\ntitle: \"Conquering Daily Data: How to Aggregate to Months and Years Like a Pro in R\"\nauthor: \"Steven P. Sanderson II, MPH\"\ndate: \"2024-01-08\"\ncategories: [code, rtip, timeseries]\n---\n\n\n# Introduction\n\nTaming the beast of daily data can be daunting. While it captures every detail, sometimes you need a bird's-eye view. Enter aggregation, your secret weapon for transforming daily data into monthly and yearly insights. In this post, we'll dive into the world of R, where you'll wield powerful tools like `dplyr` and `lubridate` to master this data wrangling art.\n\n# Packages: Gear Up with the Right Packages\n\nThink of R packages like your trusty toolbox. Today, we'll need two essentials:\n\n*   `dplyr`: This swiss army knife lets you manipulate and summarize data like a boss.\n* `lubridate`: Time is our domain, and `lubridate` helps us navigate it with precision, especially for dates.\n\n# Sample Data, Our Training Ground\n\nImagine you have daily sales data for a year. Each row represents a day, with columns for date, product, and sales amount. Let's create a mini version:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(lubridate)\n\n# Generate random dates and sales\nset.seed(123)\ndates <- seq(as.Date('2023-01-01'), as.Date('2023-12-31'), by = 'day')\nsales <- runif(365, min=5000, max=10000)\n\n# Create our data frame\ndaily_data <- data.frame(date = dates, sales = sales)\n\n# Peek at our data\nhead(daily_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        date    sales\n1 2023-01-01 6437.888\n2 2023-01-02 8941.526\n3 2023-01-03 7044.885\n4 2023-01-04 9415.087\n5 2023-01-05 9702.336\n6 2023-01-06 5227.782\n```\n:::\n:::\n\n\nThis code generates 10 random dates and sales figures, and stores them in a data frame called `daily_data`.\n\n# Monthly Magic – From Days to Months\n\nNow, let's transform this daily data into monthly insights. Here's the incantation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Group data by month\nmonthly_data <- daily_data %>%\n   # Group by month extracted from date\n  group_by(month = month(date)) %>%\n  # Calculate total sales for each month\n  summarize(total_sales = sum(sales))\n\nhead(monthly_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 2\n  month total_sales\n  <dbl>       <dbl>\n1     1     245675.\n2     2     199109.\n3     3     233764.\n4     4     227888.\n5     5     230928.\n6     6     222015.\n```\n:::\n:::\n\n\nLet's break it down:\n\n* `group_by(month = month(date))`: We tell R to group our data by the month extracted from the `date` column.\n* `summarize(total_sales = sum(sales))`: Within each month group, we calculate the total sales by summing the `sales` values.\n\n# Yearly Triumph – Conquering the Calendar\n\nYearning for yearly insights? Fear not! Modify the spell slightly:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Group data by year\nyearly_data <- daily_data %>%\n  # Group by year extracted from date\n  group_by(year = year(date)) %>%\n  # Calculate average sales for each year\n  summarize(average_sales = mean(sales))\n\nhead(yearly_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 2\n   year average_sales\n  <dbl>         <dbl>\n1  2023         7494.\n```\n:::\n:::\n\n\nHere, we group by the year extracted from `date` and then calculate the average sales for each year.\n\n# But what about base R?\n\nSo far, we've used `dplyr` to group and summarize our data. But what if you don't have `dplyr`? No problem! You can use base R functions like `aggregate()` to achieve the same results:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmonthly_data <- aggregate(\n  daily_data$sales, \n  by = list(month = format(daily_data$date, '%m')), \n  FUN = sum\n  )\nhead(monthly_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  month        x\n1    01 245675.1\n2    02 199108.7\n3    03 233764.1\n4    04 227888.3\n5    05 230928.0\n6    06 222015.3\n```\n:::\n\n```{.r .cell-code}\nyearly_data <- aggregate(\n  daily_data$sales, \n  by = list(year = format(daily_data$date, '%Y')), \n  FUN = mean\n  )\nhead(yearly_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  year      x\n1 2023 7493.8\n```\n:::\n:::\n\n# Experiment!\n\nThe magic doesn't stop there! You can customize your aggregations to your heart's content. Try these variations:\n\n* Calculate maximum sales per month.\n* Find the product with the highest average sales per year.\n* Group data by month and product to see which products perform best each month.\n\n# Remember\n\n* Play around with different `summarize()` functions like `min()`, `max()`, or `median()`.\n* Use `filter()` before `group_by()` to focus on specific subsets of data.\n* Explore other time units like weeks or quarters with lubridate's powerful tools.\n\n# The Takeaway\n\nMastering daily data aggregation is a valuable skill for any data warrior. With the help of R and your newfound knowledge, you can transform mountains of daily data into insightful monthly and yearly summaries. So, go forth, conquer your data, and share your insights with the world!\n\n**Bonus Challenge:** Share your own R code and insights in the comments below! Let's learn from each other and become daily data aggregation masters together!\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}