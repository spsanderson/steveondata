{
  "hash": "1fad99dfee60cfade70bb1362d31de82",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Complete Guide to Applying Functions to Each Row in R Matrices and Data Frames\"\nauthor: \"Steven P. Sanderson II, MPH\"\ndate: \"2025-09-15\"\ncategories: [code, rtip]\ntoc: TRUE\ndescription: \"Learn how to use the `apply()` function in R to efficiently perform row-wise operations on matrices and data frames. This comprehensive guide covers syntax, practical examples, troubleshooting tips, and best practices for R programmers looking to streamline their data analysis workflows.\"\nkeywords: [Programming, apply function in R, row-wise operations R, R data frame functions, matrix operations R, R programming apply, apply function row example, how to use apply in R, apply vs lapply in R, apply function custom function R, troubleshooting apply function R]\n---\n\n> **Key Takeaway:** The `apply()` function in R is your go-to tool for performing operations on rows or columns of matrices and data frames. With `MARGIN=1` for rows and `MARGIN=2` for columns, you can efficiently process data without writing explicit loops.\n\n# What is the apply() Function in R?\n\nThe **`apply()` function** is a powerful tool in R that allows you to apply a function to the margins (rows or columns) of an array, matrix, or data frame . Instead of writing loops, you can process entire rows or columns with a single function call, making your code cleaner and more efficient.\n\nThe `apply()` function returns a vector, array, or list of values obtained by applying a function to the specified margins . It's particularly useful for R programmers who need to perform the same operation across multiple rows or columns of data.\n\n# Basic Syntax and Arguments\n\n## Core Syntax Structure\n\n```r\napply(X, MARGIN, FUN, ...)\n```\n\n## Parameter Breakdown\n\n| Parameter | Description | Values | Example |\n|-----------|-------------|--------|---------|\n| **X** | Input data | Matrix, array, or data frame | `my_matrix` |\n| **MARGIN** | Direction of operation | `1` = rows, `2` = columns | `1` for row-wise |\n| **FUN** | Function to apply | Built-in or custom function | `sum`, `mean` |\n| **...** | Additional arguments | Extra parameters for FUN | `na.rm = TRUE` |\n\n## Key Points to Remember\n\n- **MARGIN=1**: Apply function to each **row**\n- **MARGIN=2**: Apply function to each **column** \n- **X** must be a matrix or data frame (data frames get coerced to matrices)\n- **FUN** can be any R function - built-in or user-defined \n\n# Row-wise Operations with apply()\n\n## Basic Row Operations\n\nHere are some row wise operations using `apply()` with **MARGIN=1**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create sample matrix\nsample_matrix <- matrix(1:12, nrow=3, ncol=4)\ncolnames(sample_matrix) <- c('A', 'B', 'C', 'D')\n\n# Row sums\napply(sample_matrix, 1, sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 22 26 30\n```\n\n\n:::\n\n```{.r .cell-code}\n# Row means  \napply(sample_matrix, 1, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.5 6.5 7.5\n```\n\n\n:::\n\n```{.r .cell-code}\n# Row maximums\napply(sample_matrix, 1, max)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10 11 12\n```\n\n\n:::\n\n```{.r .cell-code}\n# Row minimums\napply(sample_matrix, 1, min)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n:::\n\n\n## Custom Functions for Rows\n\nYou can create custom functions for more complex row operations:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Custom function: Calculate range (max - min) for each row\nrow_range <- function(x) { max(x) - min(x) }\napply(sample_matrix, 1, row_range)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 9 9 9\n```\n\n\n:::\n\n```{.r .cell-code}\n# Custom function: Count values greater than 5 in each row\ncount_gt5 <- function(x) { sum(x > 5) }\napply(sample_matrix, 1, count_gt5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\n# Custom function: Standard deviation for each row\napply(sample_matrix, 1, sd)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.872983 3.872983 3.872983\n```\n\n\n:::\n:::\n\n\n## Working with Data Frames\n\nWhen applying functions to data frame rows, ensure all columns are numeric:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create numeric data frame\nscores <- data.frame(\n  math = c(85, 90, 78, 92),\n  science = c(88, 85, 91, 87),\n  english = c(82, 95, 88, 90)\n)\n\n# Calculate student averages (row-wise means)\napply(scores, 1, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 85.00000 90.00000 85.66667 89.66667\n```\n\n\n:::\n:::\n\n\n# Column-wise Operations\n\nWhile the focus is on rows, understanding column operations helps you use `apply()` more effectively:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Column operations with MARGIN=2\napply(sample_matrix, 2, sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n A  B  C  D \n 6 15 24 33 \n```\n\n\n:::\n\n```{.r .cell-code}\napply(sample_matrix, 2, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n A  B  C  D \n 2  5  8 11 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Subject averages from scores data frame  \napply(scores, 2, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   math science english \n  86.25   87.75   88.75 \n```\n\n\n:::\n:::\n\n\n# Advanced Custom Functions\n\n## Functions with Additional Arguments\n\nYou can pass extra arguments to your functions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Weighted average function\nweighted_mean <- function(x, weights) {\n  sum(x * weights) / sum(weights)\n}\n\n# Apply with custom weights\nweights <- c(0.4, 0.3, 0.3)\napply(scores, 1, weighted_mean, weights = weights)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 85.0 90.0 84.9 89.9\n```\n\n\n:::\n:::\n\n\n## Complex Conditional Logic\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Grade analysis function\ngrade_analysis <- function(scores) {\n  avg <- mean(scores)\n  if (avg >= 90) {\n    return(paste('A grade, average:', round(avg, 1)))\n  } else if (avg >= 80) {\n    return(paste('B grade, average:', round(avg, 1)))\n  } else {\n    return(paste('C grade, average:', round(avg, 1)))\n  }\n}\n\napply(scores, 1, grade_analysis)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"B grade, average: 85\"   \"A grade, average: 90\"   \"B grade, average: 85.7\"\n[4] \"B grade, average: 89.7\"\n```\n\n\n:::\n:::\n\n\n# Common Issues and Troubleshooting\n\n## Mixed Data Types Problem\n\n**Issue**: When using `apply()` on data frames with mixed types, R converts everything to character .\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Problematic mixed data frame\nmixed_data <- data.frame(\n  name = c('Alice', 'Bob', 'Charlie'),\n  score1 = c(85, 90, 78),\n  score2 = c(88, 85, 91)\n)\n\n# This converts numbers to text!\napply(mixed_data, 1, function(x) paste(x, collapse = ' | '))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Alice | 85 | 88\"   \"Bob | 90 | 85\"     \"Charlie | 78 | 91\"\n```\n\n\n:::\n:::\n\n\n**Solution**: Select only numeric columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Select only numeric columns\n# Better approach\napply(mixed_data[, c('score1', 'score2')], 1, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 86.5 87.5 84.5\n```\n\n\n:::\n:::\n\n\n## Error Handling\n\n**Issue**: If one row causes an error, the entire `apply()` stops .\n\n**Solution**: Use `tryCatch()` for robust functions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsafe_log <- function(x) {\n  tryCatch({\n    if (any(x <= 0)) {\n      return(NA)\n    }\n    return(log(x))\n  }, error = function(e) NA)\n}\n\ntest_data <- matrix(c(1, -2, 3, 4, 5, 0), nrow=2)\napply(test_data, 1, safe_log)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 0.000000 1.098612 1.609438\n\n[[2]]\n[1] NA\n```\n\n\n:::\n:::\n\n\n# Performance Alternatives\n\nFor simple operations, use specialized functions instead of `apply()`:\n\n| Operation | apply() Version | Faster Alternative |\n|-----------|----------------|-------------------|\n| Row sums | `apply(X, 1, sum)` | `rowSums(X)` |\n| Row means | `apply(X, 1, mean)` | `rowMeans(X)` |\n| Column sums | `apply(X, 2, sum)` | `colSums(X)` |\n| Column means | `apply(X, 2, mean)` | `colMeans(X)` |\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Performance comparison\ntest_matrix <- matrix(1:12, nrow=3, ncol=4)\n\n# These are equivalent but rowSums() is faster:\napply(test_matrix, 1, sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 22 26 30\n```\n\n\n:::\n\n```{.r .cell-code}\nrowSums(test_matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 22 26 30\n```\n\n\n:::\n:::\n\n\nLet's do a simple benchmark test using `rbenchmark`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rbenchmark)\nlibrary(ggplot2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'ggplot2' was built under R version 4.5.1\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(dplyr)\n\n# 1000 by 1000 matrix\ntest_matrix <- matrix(rnorm(1000 * 1000), nrow=1000)\n\nbenchmark_test_tbl <- benchmark(\n  \"apply\" = apply(test_matrix, 1, sum),\n  \"rowSums\" = rowSums(test_matrix),\n  replications = 100L,\n  columns = c(\"test\",\"replications\",\"elapsed\", \"relative\",\"user.self\",\"sys.self\")\n)\n\nbenchmark_test_tbl |>\n        arrange(relative)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     test replications elapsed relative user.self sys.self\n1 rowSums          100    0.42    1.000      0.36     0.01\n2   apply          100    2.97    7.071      1.84     0.83\n```\n\n\n:::\n\n```{.r .cell-code}\n# Visualize the results in a boxplot\nbenchmark_test_tbl |>\n        ggplot(aes(x = test, y = elapsed)) +\n        geom_bar(stat = \"identity\", alpha = 0.328, aes(fill = factor(test))) +\n        theme_minimal() +\n        labs(\n                title = \"Benchmark of apply() vs rowSums\",\n                x = \"Function\",\n                y = \"Elapsed Time (s)\",\n                fill = \"Test\"\n        )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n# Alternative Approaches\n\n## Other Apply Family Functions\n\n- **`lapply()`**: Works with lists, returns a list \n- **`sapply()`**: Simplifies `lapply()` output to vectors   \n- **`mapply()`**: Multivariate version for multiple inputs \n\n## Tidyverse Alternatives\n\nFor complex row operations, consider:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n# Row-wise operations in dplyr\nscores %>% rowwise() %>% mutate(avg = mean(c(math, science, english)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 Ã— 4\n# Rowwise: \n   math science english   avg\n  <dbl>   <dbl>   <dbl> <dbl>\n1    85      88      82  85  \n2    90      85      95  90  \n3    78      91      88  85.7\n4    92      87      90  89.7\n```\n\n\n:::\n:::\n\n\n# Best Practices Checklist\n\nâœ… **Use `MARGIN=1` for rows, `MARGIN=2` for columns**  \nâœ… **Ensure data is numeric before using apply()**  \nâœ… **Use `rowSums()`, `colSums()`, `rowMeans()`, `colMeans()` for simple operations**  \nâœ… **Test custom functions on individual rows/columns first**  \nâœ… **Add error handling with `tryCatch()` for robust functions**  \nâœ… **Consider alternatives for mixed-type data frames**  \nâœ… **Remember that data frames are coerced to matrices**\n\n# Quick Reference Table\n\n| Task | Code Example | MARGIN | Output |\n|------|-------------|--------|---------|\n| Row sum | `apply(X, 1, sum)` | 1 | Vector of row sums |\n| Row mean | `apply(X, 1, mean)` | 1 | Vector of row means |\n| Custom function | `apply(X, 1, my_func)` | 1 | Vector of results |\n| With arguments | `apply(X, 1, func, arg=value)` | 1 | Vector with custom args |\n| Anonymous function | `apply(X, 1, function(x) ...)` | 1 | Vector from custom logic |\n\n# Your Turn!\n\nNow it's time to put your knowledge into practice! Below is a real-world scenario that will test your understanding of the `apply()` function for row-wise operations.\n\n## **Practice Scenario: Student Performance Analysis**\n\nYou're analyzing test scores for students in a programming course. Each student took four exams: **Midterm 1**, **Midterm 2**, **Final Project**, and **Final Exam**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Student score data\nstudent_scores <- data.frame(\n  student_id = c(\"STU001\", \"STU002\", \"STU003\", \"STU004\", \"STU005\"),\n  midterm1 = c(85, 92, 78, 88, 95),\n  midterm2 = c(89, 87, 82, 91, 88),\n  project = c(93, 95, 85, 89, 92),\n  final_exam = c(91, 89, 79, 93, 96)\n)\n```\n:::\n\n\n## **Tasks to Complete:**\n\n**Task 1:** Calculate the average score for each student across all four exams.\n\n**Task 2:** Find the highest score achieved by each student.\n\n**Task 3:** Create a custom function that determines if a student's average is above 85. Apply this function to each student.\n\n**Task 4:** Calculate the range (difference between highest and lowest score) for each student.\n\n**Task 5:** Determine how many scores above 90 each student achieved.\n\n## **Your Challenge:**\n\nWrite R code using the `apply()` function to solve each task. Remember:\n\n- Use `MARGIN = 1` for row-wise operations\n- Select only the numeric columns (exclude `student_id`)\n- Test your code step by step\n\n## **Hints:**\n\n- For numeric columns only: `student_scores[, 2:5]` or `student_scores[, -1]`\n- Custom functions can be defined inline: `function(x) { your_logic_here }`\n- Use `sum(x > 90)` to count values above a threshold\n\n<details>\n<summary>Click here for Solution!</summary>\n\nHere's the complete solution with explanations:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load the data\nstudent_scores <- data.frame(\n  student_id = c(\"STU001\", \"STU002\", \"STU003\", \"STU004\", \"STU005\"),\n  midterm1 = c(85, 92, 78, 88, 95),\n  midterm2 = c(89, 87, 82, 91, 88),\n  project = c(93, 95, 85, 89, 92),\n  final_exam = c(91, 89, 79, 93, 96)\n)\n\n# Extract only numeric columns (exclude student_id)\nscores_only <- student_scores[, 2:5]\n\n# Task 1: Calculate average score for each student\nstudent_averages <- apply(scores_only, 1, mean)\nprint(\"Student Averages:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Student Averages:\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(student_averages)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 89.50 90.75 81.00 90.25 92.75\n```\n\n\n:::\n\n```{.r .cell-code}\n# Task 2: Find highest score for each student  \nstudent_max <- apply(scores_only, 1, max)\nprint(\"Student Maximum Scores:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Student Maximum Scores:\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(student_max)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 93 95 85 93 96\n```\n\n\n:::\n\n```{.r .cell-code}\n# Task 3: Custom function - average above 85?\nabove_85 <- function(x) {\n  avg <- mean(x)\n  return(avg > 85)\n}\nstudent_above_85 <- apply(scores_only, 1, above_85)\nprint(\"Students with average above 85:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Students with average above 85:\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(student_above_85)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE  TRUE FALSE  TRUE  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n# Task 4: Calculate range for each student\nstudent_range <- apply(scores_only, 1, function(x) max(x) - min(x))\nprint(\"Student Score Ranges:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Student Score Ranges:\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(student_range)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8 8 7 5 8\n```\n\n\n:::\n\n```{.r .cell-code}\n# Task 5: Count scores above 90 for each student\nscores_above_90 <- apply(scores_only, 1, function(x) sum(x > 90))\nprint(\"Number of scores above 90 per student:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Number of scores above 90 per student:\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(scores_above_90)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 2 0 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\n# Bonus: Create a comprehensive summary\nstudent_summary <- data.frame(\n  student_id = student_scores$student_id,\n  average = round(student_averages, 2),\n  max_score = student_max,\n  above_85_avg = student_above_85,\n  score_range = student_range,\n  scores_above_90 = scores_above_90\n)\n\nprint(\"Complete Student Summary:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Complete Student Summary:\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(student_summary)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  student_id average max_score above_85_avg score_range scores_above_90\n1     STU001   89.50        93         TRUE           8               2\n2     STU002   90.75        95         TRUE           8               2\n3     STU003   81.00        85        FALSE           7               0\n4     STU004   90.25        93         TRUE           5               2\n5     STU005   92.75        96         TRUE           8               3\n```\n\n\n:::\n:::\n\n\n**Key Learning Points:**\n\n- **Data Selection**: We used student_scores[, 2:5]` to select only numeric columns, avoiding issues with mixed data types\n- **Custom Functions**: Task 3 and 5 showed how to write custom functions and apply them row-wise\n- **Anonymous Functions**: Tasks 4 and 5 used `function(x)` inline for concise operations\n- **Practical Application**: This exercise mirrors real-world data analysis scenarios\n\n**Alternative Solutions:**\n```r\n# You could also use:\n# For averages: rowMeans(scores_only) - faster for simple means\n# For sums: rowSums(scores_only) - faster for simple sums\n# But apply() gives you more flexibility for custom operations!\n```\n\n</details>\n\n## **Test Your Understanding**\n\nAfter completing the exercise, ask yourself:\n\n1. **Why did we exclude the `student_id` column?** *(Hint: mixed data types)*\n2. **Could we use `rowMeans()` instead of `apply()` for Task 1?** *(Yes, but apply() is more flexible)*\n3. **How would you modify the code to handle missing values (NA)?** *(Add `na.rm = TRUE`)*\n\n## **Next Steps**\n\nTry modifying the exercise:\n\n- Add a sixth student with some missing scores (`NA`)\n- Create a function that assigns letter grades based on averages\n- Calculate weighted averages (e.g., final exam worth 40%, others 20% each)\n\n**Great job working through this exercise!** You've now practiced the core concepts of using `apply()` for row-wise operations in real-world scenarios. This foundation will serve you well in data analysis projects.\n\n# Conclusion\n\nThe `apply()` function is an essential tool for R programmers working with matrices and data frames. By using **MARGIN=1** for row-wise operations, you can efficiently process data without explicit loops. Remember to handle mixed data types carefully, consider performance alternatives for simple operations, and add error handling for robust code.\n\n**Key Takeaways:**\n\n- Use `apply(X, 1, FUN)` for row-wise operations\n- Handle mixed data types by selecting numeric columns only  \n- Consider `rowSums()`, `rowMeans()` for better performance on simple operations\n- Add error handling with `tryCatch()` for production code\n- Test custom functions thoroughly before applying to large datasets\n\nStart experimenting with `apply()` in your next R project - it will make your data processing code cleaner and more efficient!\n\n# References\n\n1. **R Documentation** - [apply: Apply Functions Over Array Margins](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/apply)  \n   *Official R documentation for the apply() function, including detailed syntax, arguments, usage examples, and technical specifications.*\n\n2. **DataQuest** - [Apply Functions in R with Examples](https://www.dataquest.io/blog/apply-functions-in-r-sapply-lapply-tapply/)  \n   *In-depth tutorial explaining the apply() function family in R with practical data analysis examples, comparing efficiency with loops and vectorized operations.*\n\n3. **R-bloggers** - [Complete Tutorial on Using 'apply' Functions in R](https://www.r-bloggers.com/2022/03/complete-tutorial-on-using-apply-functions-in-r/)  \n   *Step-by-step guide featuring real-world data analysis examples, custom function applications, and best practices for using apply() functions efficiently.*\n\n------------------------------------------------------------------------\n\nHappy Coding! ðŸš€\n\n![Using apply() in R](todays_post.png)\n\n------------------------------------------------------------------------\n\n*You can connect with me at any one of the below*:\n\n*Telegram Channel here*: <https://t.me/steveondata>\n\n*LinkedIn Network here*: <https://www.linkedin.com/in/spsanderson/>\n\n*Mastadon Social here*: [https://mstdn.social/\\@stevensanderson](https://mstdn.social/@stevensanderson)\n\n*RStats Network here*: [https://rstats.me/\\@spsanderson](https://rstats.me/@spsanderson)\n\n*GitHub Network here*: <https://github.com/spsanderson>\n\n*Bluesky Network here*: <https://bsky.app/profile/spsanderson.com>\n\n*My Book: Extending Excel with Python and R* here: <https://packt.link/oTyZJ>\n\n*You.com Referral Link*: <https://you.com/join/EHSLDTL6>\n\n------------------------------------------------------------------------\n\n```{=html}\n<script src=\"https://giscus.app/client.js\"\n        data-repo=\"spsanderson/steveondata\"\n        data-repo-id=\"R_kgDOIIxnLw\"\n        data-category=\"Comments\"\n        data-category-id=\"DIC_kwDOIIxnL84ChTk8\"\n        data-mapping=\"url\"\n        data-strict=\"0\"\n        data-reactions-enabled=\"1\"\n        data-emit-metadata=\"0\"\n        data-input-position=\"top\"\n        data-theme=\"dark\"\n        data-lang=\"en\"\n        data-loading=\"lazy\"\n        crossorigin=\"anonymous\"\n        async>\n</script>\n```",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}