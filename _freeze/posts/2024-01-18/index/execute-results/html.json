{
  "hash": "d1ded5b68fe82f2421c7e02b90e3264f",
  "result": {
    "markdown": "---\ntitle: \"Exploring the Enhanced Features of tidyAML's internal_make_wflw_predictions()\"\nauthor: \"Steven P. Sanderson II, MPH\"\ndate: \"2024-01-18\"\ncategories: [code, rtip, tidyaml]\n---\n\n\n# Introduction\n\nHey R enthusiasts! Steve here, and today I'm excited to share some fantastic updates about a key function in the tidyAML package – `internal_make_wflw_predictions()`. The latest version addresses issue #190, ensuring that all crucial data is now included in the predictions. Let's dive into the details!\n\n# What's New?\n\nIn response to user feedback, we've enhanced the `internal_make_wflw_predictions()` function to provide a comprehensive set of predictions. Now, when you make a call to this function, it includes:\n\n1. **The Actual Data:** This is the real-world data that your model aims to predict. Having access to this information helps you assess how well your model is performing on unseen instances.\n\n2. **Training Predictions:** Predictions made on the training dataset. This is essential for understanding how well your model generalizes to the data it was trained on.\n\n3. **Testing Predictions:** Predictions made on the testing dataset. This is crucial for evaluating the model's performance on data it hasn't seen during the training phase.\n\n# How to Use It\n\nTo take advantage of these new features, here's how you can use the updated `internal_make_wflw_predictions()` function:\n\n```R\ninternal_make_wflw_predictions(.model_tbl, .splits_obj)\n```\n\n## Arguments:\n\n1. **.model_tbl:** The model table generated from a function like `fast_regression_parsnip_spec_tbl()`. Ensure that it has a class of \"tidyaml_mod_spec_tbl.\" This is typically used after running the `internal_make_fitted_wflw()` function and saving the resulting tibble.\n\n2. **.splits_obj:** The splits object obtained from the `auto_ml` function. It is internal to the `auto_ml` function.\n\n# Example Usage\n\nLet's walk through an example using some popular R packages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidymodels)\nlibrary(tidyAML)\nlibrary(tidyverse)\ntidymodels_prefer()\n\n# Create a model specification table\nmod_spec_tbl <- fast_regression_parsnip_spec_tbl(\n  .parsnip_eng = c(\"lm\",\"glm\"),\n  .parsnip_fns = \"linear_reg\"\n)\n\n# Create a recipe\nrec_obj <- recipe(mpg ~ ., data = mtcars)\n\n# Create splits\nsplits_obj <- create_splits(mtcars, \"initial_split\")\n\n# Generate the model table\nmod_tbl <- mod_spec_tbl |>\n  mutate(wflw = full_internal_make_wflw(mod_spec_tbl, rec_obj))\n\n# Generate the fitted model table\nmod_fitted_tbl <- mod_tbl |>\n  mutate(fitted_wflw = internal_make_fitted_wflw(mod_tbl, splits_obj))\n\n# Make predictions with the enhanced function\npreds_list <- internal_make_wflw_predictions(mod_fitted_tbl, splits_obj)\n```\n:::\n\n\nThis example demonstrates how to integrate the updated function into your workflow seamlessly. Typically though one would not use this function directly, but rather use the `fast_regression()` or `fast_classification()` function, which calls this function internally. Let's now take a look at the output of everything.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrec_obj\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n── Recipe ──────────────────────────────────────────────────────────────────────\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n── Inputs \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nNumber of variables by role\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\noutcome:    1\npredictor: 10\n```\n:::\n\n```{.r .cell-code}\nsplits_obj\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$splits\n<Training/Testing/Total>\n<24/8/32>\n\n$split_type\n[1] \"initial_split\"\n```\n:::\n\n```{.r .cell-code}\nmod_spec_tbl\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 5\n  .model_id .parsnip_engine .parsnip_mode .parsnip_fns model_spec\n      <int> <chr>           <chr>         <chr>        <list>    \n1         1 lm              regression    linear_reg   <spec[+]> \n2         2 glm             regression    linear_reg   <spec[+]> \n```\n:::\n\n```{.r .cell-code}\nmod_tbl\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 6\n  .model_id .parsnip_engine .parsnip_mode .parsnip_fns model_spec wflw      \n      <int> <chr>           <chr>         <chr>        <list>     <list>    \n1         1 lm              regression    linear_reg   <spec[+]>  <workflow>\n2         2 glm             regression    linear_reg   <spec[+]>  <workflow>\n```\n:::\n\n```{.r .cell-code}\nmod_fitted_tbl\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 7\n  .model_id .parsnip_engine .parsnip_mode .parsnip_fns model_spec wflw      \n      <int> <chr>           <chr>         <chr>        <list>     <list>    \n1         1 lm              regression    linear_reg   <spec[+]>  <workflow>\n2         2 glm             regression    linear_reg   <spec[+]>  <workflow>\n# ℹ 1 more variable: fitted_wflw <list>\n```\n:::\n\n```{.r .cell-code}\npreds_list\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n# A tibble: 64 × 3\n   .data_category .data_type .value\n   <chr>          <chr>       <dbl>\n 1 actual         actual       15.2\n 2 actual         actual       19.7\n 3 actual         actual       17.8\n 4 actual         actual       15  \n 5 actual         actual       10.4\n 6 actual         actual       15.8\n 7 actual         actual       17.3\n 8 actual         actual       30.4\n 9 actual         actual       15.2\n10 actual         actual       19.2\n# ℹ 54 more rows\n\n[[2]]\n# A tibble: 64 × 3\n   .data_category .data_type .value\n   <chr>          <chr>       <dbl>\n 1 actual         actual       15.2\n 2 actual         actual       19.7\n 3 actual         actual       17.8\n 4 actual         actual       15  \n 5 actual         actual       10.4\n 6 actual         actual       15.8\n 7 actual         actual       17.3\n 8 actual         actual       30.4\n 9 actual         actual       15.2\n10 actual         actual       19.2\n# ℹ 54 more rows\n```\n:::\n:::\n\n\nYou will notice the names of the preds_list output:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(preds_list[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \".data_category\" \".data_type\"     \".value\"        \n```\n:::\n:::\n\n\nSo we have `.data_category`, `.data_type`, and `.value`. Let's take a look at the unique values of each column for `.data_category` and `.data_type`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunique(preds_list[[1]]$.data_category)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"actual\"    \"predicted\"\n```\n:::\n:::\n\n\nSo we have our `actual` data the the `predicted` data. The predicted though has both the `training` and `testing` data in it. Let's take a look at the unique values of `.data_type`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunique(preds_list[[1]]$.data_type)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"actual\"   \"training\" \"testing\" \n```\n:::\n:::\n\n\nThis will allow you to visualize the data how you please, something we will go over tomorrow!\n\n## Why It Matters\n\nBy including actual data along with training and testing predictions, the `internal_make_wflw_predictions()` function empowers you to perform a more thorough evaluation of your models. This is a significant step towards ensuring the reliability and generalization capability of your machine learning models.\n\nSo, R enthusiasts, update your tidyAML package, explore the enhanced features, and let us know how these improvements elevate your modeling experience. Happy coding!",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}