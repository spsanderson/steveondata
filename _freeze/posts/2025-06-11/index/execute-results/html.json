{
  "hash": "b902267cafb6176d4fce1d4e6eddbf5e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Python Lists, Tuples, and Dictionaries: A Beginner's Guide\"\nauthor: \"Steven P. Sanderson II, MPH\"\ndate: \"2025-06-11\"\ncategories: [code, python]\ntoc: TRUE\ndescription: \"Master Python lists, tuples, and dictionaries with this beginner-friendly guide. Learn essential methods, best practices, and practical examples!\"\nkeywords: [Programming, Python lists, Python tuples, Python data structures, Python dictionaries, Python colections, dictionary methods Python, Python mutable vs immutable, list vs tuple Python Python list operations, Python data structure comparison, convert list to tuple in Python with examples, how to choose between list tuple and dictionary in Python, best practices for passing lists to functions in Python, Python dictionary key-value pair manipulation, when to use tuples instead of lists in Python]\n---\n\n\n\n**Author's Note: I want to be transparent with you, I'm learning Python as I write this series. Rather than an expert tutorial, this is a series of discovery where I'm documenting concepts as I understand them, sharing insights, and yes, occasionally making mistakes along the way.**\n\n# Introduction\n\nPython offers several built-in collection types that make it easy to store, organize, and manipulate data. These collections are fundamental building blocks for nearly any Python program, and understanding their differences is essential for writing efficient code.\n\nThe three most commonly used collection types are:\n\n- **Lists**: Ordered, mutable collections that can store items of any type\n- **Tuples**: Ordered, immutable collections that can store items of any type\n- **Dictionaries**: Unordered, mutable collections of key-value pairs\n\nAs a beginner Python programmer, you'll find yourself using lists most frequently due to their flexibility and intuitive behavior. Lists allow you to collect related items together, modify them at any time, and perform operations like adding, removing, or rearranging elements.\n\n# Creating and Accessing Lists\n\n## List Creation Syntax\n\nPython lists are created using square brackets `[]`. You can create an empty list or initialize one with values:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreticulate::repl_python()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nPython 3.11.13 (C:/Users/ssanders/AppData/Local/R/cache/R/reticulate/uv/cache/archive-v0/KVkhPXn-Fo7Nm8piyYSN5/Scripts/python.exe)\nReticulate 1.42.0 REPL -- A Python interpreter in R.\nEnter 'exit' or 'quit' to exit the REPL and return to R.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nexit\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# Empty list\nempty_list = []\nempty_list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[]\n```\n\n\n:::\n\n```{.python .cell-code}\nalso_empty = list()  # Using the list constructor\nalso_empty\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[]\n```\n\n\n:::\n\n```{.python .cell-code}\n# List with values\nnumbers = [1, 2, 3, 4, 5]\nnumbers\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1, 2, 3, 4, 5]\n```\n\n\n:::\n\n```{.python .cell-code}\nmixed_types = [1, \"hello\", 3.14, True]\nmixed_types\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1, 'hello', 3.14, True]\n```\n\n\n:::\n\n```{.python .cell-code}\nnested_list = [1, [2, 3], 4]  # Lists can contain other lists\nnested_list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1, [2, 3], 4]\n```\n\n\n:::\n:::\n\n\n\nLists in Python can hold any type of data, including numbers, strings, booleans, and even other lists. This flexibility makes them extremely versatile.\n\n## List Indexing and Slicing\n\nPython uses zero-based **indexing**, meaning the first element is at position 0:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmy_list = ['a', 'b', 'c', 'd', 'e']\nprint(my_list[0])  # Output: 'a'\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\na\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(my_list[3])  # Output: 'd'\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nd\n```\n\n\n:::\n:::\n\n\n\nYou can also use negative indices to access elements from the end of the list:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nprint(my_list[-1])  # Output: 'e' (last element)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ne\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(my_list[-2])  # Output: 'd' (second-to-last element)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nd\n```\n\n\n:::\n:::\n\n\n\n**Slicing** allows you to extract a portion of a list using the syntax `[start:stop:step]`:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nprint(my_list[1:4])    # Output: ['b', 'c', 'd']\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n['b', 'c', 'd']\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(my_list[:3])     # Output: ['a', 'b', 'c']\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n['a', 'b', 'c']\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(my_list[2:])     # Output: ['c', 'd', 'e']\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n['c', 'd', 'e']\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(my_list[::2])    # Output: ['a', 'c', 'e']\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n['a', 'c', 'e']\n```\n\n\n:::\n:::\n\n\n\n# Understanding List Mutability\n\n## What Makes Lists Mutable\n\nIn programming, **mutability** refers to whether an object can be changed after it's created. Lists are **mutable**, meaning you can modify, add, or remove elements without creating a new list:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nnumbers = [1, 2, 3]\nnumbers[0] = 10        # Modify the first element\nprint(numbers)         # Output: [10, 2, 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[10, 2, 3]\n```\n\n\n:::\n:::\n\n\n\nThis mutability is a key feature that distinguishes lists from **immutable** types like tuples, which cannot be changed after creation.\n\n## Variables and References\n\nWhen you assign a list to a variable, Python creates a reference to the list rather than a new copy. This means multiple variables can point to the same list:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nlist_a = [1, 2, 3]\nlist_b = list_a        # list_b references the same list as list_a\n\nlist_b[0] = 10         # This changes the list that both variables reference\nprint(list_a)          # Output: [10, 2, 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[10, 2, 3]\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(list_b)          # Output: [10, 2, 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[10, 2, 3]\n```\n\n\n:::\n:::\n\n\n\nTo create an independent copy, you can use:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nlist_c = list_a[:]     # Creates a shallow copy using slicing\nlist_d = list_a.copy() # Another way to create a shallow copy\n\nprint(list_c)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[10, 2, 3]\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(list_d)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[10, 2, 3]\n```\n\n\n:::\n:::\n\n\n\n# Essential List Methods\n\nLists have many built-in methods that allow you to manipulate their contents efficiently. Here are the most commonly used:\n\n## Adding Elements\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmy_list = [1, 2, 3]\nprint(my_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1, 2, 3]\n```\n\n\n:::\n\n```{.python .cell-code}\n# Add an element at the end\nmy_list.append(4)      # Result: [1, 2, 3, 4]\nprint(my_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1, 2, 3, 4]\n```\n\n\n:::\n\n```{.python .cell-code}\n# Insert at a specific position\nmy_list.insert(1, 5)   # Result: [1, 5, 2, 3, 4]\nprint(my_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1, 5, 2, 3, 4]\n```\n\n\n:::\n\n```{.python .cell-code}\n# Extend with elements from another iterable\nmy_list.extend([6, 7]) # Result: [1, 5, 2, 3, 4, 6, 7]\nprint(my_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1, 5, 2, 3, 4, 6, 7]\n```\n\n\n:::\n:::\n\n\n\n## Removing Elements\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmy_list = [1, 2, 3, 2, 4]\nprint(my_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1, 2, 3, 2, 4]\n```\n\n\n:::\n\n```{.python .cell-code}\n# Remove by value (first occurrence)\nmy_list.remove(2)      # Result: [1, 3, 2, 4]\nprint(my_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1, 3, 2, 4]\n```\n\n\n:::\n\n```{.python .cell-code}\n# Remove by index\ndel my_list[2]         # Result: [1, 3, 4]\nprint(my_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1, 3, 4]\n```\n\n\n:::\n\n```{.python .cell-code}\n# Remove and return the element at a specific index\npopped = my_list.pop(1)  # popped = 3, my_list = [1, 4]\nprint(popped)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n3\n```\n\n\n:::\n:::\n\n\n\n## Finding and Organizing Elements\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmy_list = [3, 1, 4, 1, 5, 9]\nprint(my_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[3, 1, 4, 1, 5, 9]\n```\n\n\n:::\n\n```{.python .cell-code}\n# Find the index of the first occurrence\nposition = my_list.index(4)  # Result: 2\nprint(position)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n2\n```\n\n\n:::\n\n```{.python .cell-code}\n# Count occurrences\ncount = my_list.count(1)     # Result: 2\nprint(count)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n2\n```\n\n\n:::\n\n```{.python .cell-code}\n# Reverse the list in place\nmy_list.reverse()            # Result: [9, 5, 1, 4, 1, 3]\n\n# Sort the list in place\nmy_list.sort()               # Result: [1, 1, 3, 4, 5, 9]\n\n# Get a sorted copy without modifying the original\nsorted_list = sorted(my_list)\nprint(sorted_list)          # Output: [1, 1, 3, 4, 5, 9]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1, 1, 3, 4, 5, 9]\n```\n\n\n:::\n:::\n\n\n\n# List Iteration and Comprehensions\n\n## Iterating Through Lists\n\nThe most common way to iterate through a list is with a `for` loop:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfruits = ['apple', 'banana', 'cherry']\nfor fruit in fruits:\n    print(fruit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\napple\nbanana\ncherry\n```\n\n\n:::\n:::\n\n\n\nWhen you need both the index and value, use `enumerate()`:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfor index, fruit in enumerate(fruits):\n    print(f\"Item {index}: {fruit}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nItem 0: apple\nItem 1: banana\nItem 2: cherry\n```\n\n\n:::\n:::\n\n\n\n## List Comprehensions\n\nList comprehensions provide a concise way to create lists from existing iterables:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Create a list of squares\nsquares = [x**2 for x in range(5)]  # [0, 1, 4, 9, 16]\nprint(squares)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[0, 1, 4, 9, 16]\n```\n\n\n:::\n\n```{.python .cell-code}\n# Filter elements \neven_squares = [x**2 for x in range(10) if x % 2 == 0]  # [0, 4, 16, 36, 64]\nprint(even_squares)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[0, 4, 16, 36, 64]\n```\n\n\n:::\n:::\n\n\n\nThis syntax is often more readable and efficient than building lists with for loops.\n\n# Tuples: Immutable Ordered Collections\n\n## Creating and Using Tuples\n\nTuples are similar to lists but are **immutable** (cannot be changed after creation). They're created using parentheses:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nempty_tuple = ()\nprint(empty_tuple)  # Output: ()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n()\n```\n\n\n:::\n\n```{.python .cell-code}\nsingle_item = (42,)    # Comma is required for single-item tuples!\nprint(single_item)  # Output: (42,)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(42,)\n```\n\n\n:::\n\n```{.python .cell-code}\ncoordinates = (10, 20)\nprint(coordinates)  # Output: (10, 20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(10, 20)\n```\n\n\n:::\n\n```{.python .cell-code}\nmixed_tuple = (1, \"hello\", True)\nprint(mixed_tuple)  # Output: (1, 'hello', True)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(1, 'hello', True)\n```\n\n\n:::\n:::\n\n\n\nOnce created, tuple elements cannot be modified:\n\n```python\ncoordinates = (10, 20)\n# coordinates[0] = 5  # This would raise a TypeError\n```\n\n## Lists vs Tuples: A Practical Comparison\n\n| Feature             | Lists                          | Tuples                           |\n|---------------------|--------------------------------|----------------------------------|\n| **Syntax**          | `[1, 2, 3]`                    | `(1, 2, 3)`                      |\n| **Mutability**      | Mutable (can be changed)       | Immutable (cannot be changed)    |\n| **Use Case**        | When you need to modify items  | When data should remain constant |\n| **Performance**     | Slightly slower operations     | Slightly faster operations       |\n| **Dict Keys**       | Cannot be used as dict keys    | Can be used as dict keys         |\n\nTuples are ideal for representing fixed collections like coordinates or RGB color values, while lists are better when you need to modify the content.\n\n# Dictionaries: Key-Value Collections\n\n## Dictionary Fundamentals\n\nDictionaries store data as key-value pairs, providing fast access to values via their keys:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Creating a dictionary\nperson = {\n    'name': 'Alice',\n    'age': 25,\n    'city': 'New York'\n}\n\n# Accessing values\nprint(person['name'])  # Output: 'Alice'\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAlice\n```\n\n\n:::\n\n```{.python .cell-code}\n# Adding/modifying entries\nperson['email'] = 'alice@example.com'\nperson['age'] = 26\n\nprint(person['email'])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nalice@example.com\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(person['age'])  # Output: 26\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n26\n```\n\n\n:::\n:::\n\n\n\n## Common Dictionary Methods\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Safe access with default value\nemail = person.get('email', 'Not provided')\n\n# Get all keys, values, or items\nkeys = person.keys()\nvalues = person.values()\nitems = person.items()\n\n# Iterate through key-value pairs\nfor key, value in person.items():\n    print(f\"{key}: {value}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nname: Alice\nage: 26\ncity: New York\nemail: alice@example.com\n```\n\n\n:::\n:::\n\n\n\n# Interactive Exercise: Your Turn!\n\nLet's put your knowledge into practice by creating a simple shopping list application.\n\n## The Shopping List Challenge:\n\nCreate a program that allows you to:\n\n1. Add items with quantities\n2. Remove items\n3. Update quantities\n4. Display the current list\n\nHere's a skeleton to get you started:\n\n```python\n# Challenge: Complete the ShoppingList class implementation\nclass ShoppingList:\n    def __init__(self):\n        self.items = {}  # Dictionary to store item:quantity pairs\n        \n    def add_item(self, item, quantity=1):\n        # Your code here\n        pass\n            \n    def remove_item(self, item):\n        # Your code here\n        pass\n    \n    def update_quantity(self, item, quantity):\n        # Your code here\n        pass\n            \n    def get_list(self):\n        # Your code here\n        pass\n```\n\n<details>\n<summary>Click here for Solution!</summary>\n\n```python\nclass ShoppingList:\n    def __init__(self):\n        self.items = {}  # Dictionary to store item:quantity pairs\n        \n    def add_item(self, item, quantity=1):\n        \"\"\"Add an item to the shopping list or update its quantity.\"\"\"\n        item = item.lower().strip()\n        if not item:\n            raise ValueError(\"Item name cannot be empty\")\n        if quantity <= 0:\n            raise ValueError(\"Quantity must be positive\")\n            \n        if item in self.items:\n            self.items[item] += quantity\n        else:\n            self.items[item] = quantity\n            \n    def remove_item(self, item):\n        \"\"\"Remove an item from the shopping list.\"\"\"\n        item = item.lower().strip()\n        if item in self.items:\n            del self.items[item]\n            return True\n        return False\n    \n    def update_quantity(self, item, quantity):\n        \"\"\"Update the quantity of an existing item.\"\"\"\n        item = item.lower().strip()\n        if item not in self.items:\n            raise KeyError(f\"Item '{item}' not found in shopping list\")\n        if quantity <= 0:\n            self.remove_item(item)\n        else:\n            self.items[item] = quantity\n            \n    def get_list(self):\n        \"\"\"Return the current shopping list.\"\"\"\n        return dict(sorted(self.items.items()))\n\n# Example usage:\nshopping = ShoppingList()\nshopping.add_item(\"Apples\", 3)\nshopping.add_item(\"Bananas\", 2)\nprint(shopping.get_list())  # {'apples': 3, 'bananas': 2}\n```\n</details>\n\n# Common Pitfalls and Best Practices\n\n## Reference vs Copy\n\nOne of the most common mistakes beginners make is not understanding how references work:\n\n```python\n# WRONG (if you want independent lists)\nlist1 = [1, 2, 3]\nlist2 = list1\nlist2.append(4)  # Now list1 will also have 4!\n\n# RIGHT (creating independent copies)\nlist1 = [1, 2, 3]\nlist2 = list1.copy()  # or list1[:] for a shallow copy\nlist2.append(4)  # list1 remains [1, 2, 3]\n```\n\n## Choosing the Right Collection Type\n\n- Use **lists** when you need an ordered, mutable collection\n- Use **tuples** for fixed, immutable sequences of data\n- Use **dictionaries** when you need fast lookups by key\n\n# Quick Takeaways\n\n- **Lists** are mutable, ordered collections created with `[]`\n- **Append** adds elements to the end with `.append(item)`\n- **Remove** elements by value with `.remove(value)` or by index with `del list[index]`\n- **Reverse** a list in place with `.reverse()`\n- **Index** finds an element's position with `.index(value)`\n- Use **list comprehensions** `[expression for item in iterable]` for concise, readable code\n- **Tuples** are immutable lists, good for data that shouldn't change\n- **Dictionaries** store key-value pairs for fast lookups\n\n# Conclusion and Next Steps\n\nYou now have a solid foundation in Python's core collection types, particularly lists. Practice using these structures in your own programs to reinforce your understanding. As you advance, explore more specialized collections in the `collections` module like `Counter`, `defaultdict`, and `namedtuple` for more specific use cases.\n\n# FAQ Section\n\n**Q: Can lists contain different types of data?**  \nA: Yes, Python lists can contain mixed data types, including other lists.\n\n**Q: When should I use a list vs. a tuple?**  \nA: Use lists when you need to modify the collection and tuples when the data should remain constant.\n\n**Q: Are dictionaries ordered in Python?**  \nA: Since Python 3.7, dictionaries maintain insertion order, but they're still optimized for lookups by key, not by position.\n\n**Q: How do I sort a list in reverse order?**  \nA: Use `my_list.sort(reverse=True)` or `sorted(my_list, reverse=True)`.\n\n**Q: Can I have duplicate values in a list?**  \nA: Yes, lists can contain duplicate values, unlike sets which only store unique elements.\n\n# References\n\n1. Python Software Foundation. (2025). *Python 3.11 Documentation: Data Structures*. [Access Documentation](https://docs.python.org/3/tutorial/datastructures.html)\n   > Comprehensive guide to Python's built-in data structures including lists, tuples, and dictionaries with official syntax and usage examples.\n\n2. Python Software Foundation. (2025). *Python 3.11 Documentation: Sequence Types*. [Access Documentation](https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range)\n   > Detailed reference for sequence types including lists and tuples with all available methods and operations.\n\n3. Python Software Foundation. (2025). *Python 3.11 Documentation: Mapping Types*. [Access Documentation](https://docs.python.org/3/library/stdtypes.html#mapping-types-dict)\n   > Complete reference for dictionary operations, methods, and examples of common usage patterns.\n\n---\n\n**I hope this guide helps you understand and use Python's collection types effectively. Remember that practice is key to mastering these concepts. Try building small projects that use different collection types to reinforce your learning.**\n\n------------------------------------------------------------------------\n\nHappy Coding! ðŸš€\n\n![Lists in Python](todays_post.png)\n\n------------------------------------------------------------------------\n\n*You can connect with me at any one of the below*:\n\n*Telegram Channel here*: <https://t.me/steveondata>\n\n*LinkedIn Network here*: <https://www.linkedin.com/in/spsanderson/>\n\n*Mastadon Social here*: [https://mstdn.social/\\@stevensanderson](https://mstdn.social/@stevensanderson)\n\n*RStats Network here*: [https://rstats.me/\\@spsanderson](https://rstats.me/@spsanderson)\n\n*GitHub Network here*: <https://github.com/spsanderson>\n\n*Bluesky Network here*: <https://bsky.app/profile/spsanderson.com>\n\n*My Book: Extending Excel with Python and R* here: <https://packt.link/oTyZJ>\n\n*You.com Referral Link*: <https://you.com/join/EHSLDTL6>\n\n------------------------------------------------------------------------\n\n\n\n```{=html}\n<script src=\"https://giscus.app/client.js\"\n        data-repo=\"spsanderson/steveondata\"\n        data-repo-id=\"R_kgDOIIxnLw\"\n        data-category=\"Comments\"\n        data-category-id=\"DIC_kwDOIIxnL84ChTk8\"\n        data-mapping=\"url\"\n        data-strict=\"0\"\n        data-reactions-enabled=\"1\"\n        data-emit-metadata=\"0\"\n        data-input-position=\"top\"\n        data-theme=\"dark\"\n        data-lang=\"en\"\n        data-loading=\"lazy\"\n        crossorigin=\"anonymous\"\n        async>\n</script>\n```\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}