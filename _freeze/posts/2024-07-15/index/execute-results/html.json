{
  "hash": "c160a2f86bf8f38739da8d0809281e32",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"tidyAML: Automated Machine Learning with tidymodels\"\nauthor: \"Steven P. Sanderson II, MPH\"\ndate: \"2024-07-15\"\ncategories: [code, rtip, tidyaml]\ntoc: TRUE\n---\n\n\n# Introduction\n\nWelcome to {tidyAML} which is an R package that makes it easy to use the tidymodels ecosystem to perform automated machine learning (AutoML). This package provides a simple and intuitive interface that allows users to quickly generate machine learning models without worrying about the underlying details. It also includes a safety mechanism that ensures that the package will fail gracefully if any required extension packages are not installed on the user’s machine. With {tidyAML}, users can easily build high-quality machine learning models in just a few lines of code. Whether you are a beginner or an experienced machine learning practitioner, {tidyAML} has something to offer.\n\nSome ideas are that we should be able to generate regression models on the fly without having to actually go through the process of building the specification, especially if it is a non-tuning model, meaning we are not planing on tuning hyper-parameters like penalty and cost.\n\nThe idea is not to re-write the excellent work the tidymodels team has done (because it’s not possible) but rather to try and make an enhanced easy to use set of functions that do what they say and can generate many models and predictions at once.\n\nThis is similar to the great h2o package, but, {tidyAML} does not require java to be setup properly like h2o because {tidyAML} is built on tidymodels.\n\n# Installation\n\nYou can install {tidyAML} like so:\n\n```r\ninstall.packages(\"tidyAML\")\n```\n\nOr the development version from GitHub\n\n```r\n# install.packages(\"devtools\")\ndevtools::install_github(\"spsanderson/tidyAML\")\n```\n\nPart of the reason to use {tidyAML} is so that you can generate many models of your data set. One way of modeling a data set is using regression for some numeric output. There is a convienent function in tidyAML that will generate a set of non-tuning models for fast regression. Let’s take a look below.\n\nFirst let’s load the library\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyAML)\n```\n:::\n\nNow lets see the function in action.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfast_regression_parsnip_spec_tbl(.parsnip_fns = \"linear_reg\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 11 × 5\n   .model_id .parsnip_engine .parsnip_mode .parsnip_fns model_spec\n       <int> <chr>           <chr>         <chr>        <list>    \n 1         1 lm              regression    linear_reg   <spec[+]> \n 2         2 brulee          regression    linear_reg   <spec[+]> \n 3         3 gee             regression    linear_reg   <spec[+]> \n 4         4 glm             regression    linear_reg   <spec[+]> \n 5         5 glmer           regression    linear_reg   <spec[+]> \n 6         6 glmnet          regression    linear_reg   <spec[+]> \n 7         7 gls             regression    linear_reg   <spec[+]> \n 8         8 lme             regression    linear_reg   <spec[+]> \n 9         9 lmer            regression    linear_reg   <spec[+]> \n10        10 stan            regression    linear_reg   <spec[+]> \n11        11 stan_glmer      regression    linear_reg   <spec[+]> \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfast_regression_parsnip_spec_tbl(.parsnip_eng = c(\"lm\",\"glm\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 5\n  .model_id .parsnip_engine .parsnip_mode .parsnip_fns model_spec\n      <int> <chr>           <chr>         <chr>        <list>    \n1         1 lm              regression    linear_reg   <spec[+]> \n2         2 glm             regression    linear_reg   <spec[+]> \n3         3 glm             regression    poisson_reg  <spec[+]> \n```\n\n\n:::\n\n```{.r .cell-code}\nfast_regression_parsnip_spec_tbl(.parsnip_eng = c(\"lm\",\"glm\",\"gee\"), \n                                 .parsnip_fns = \"linear_reg\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 5\n  .model_id .parsnip_engine .parsnip_mode .parsnip_fns model_spec\n      <int> <chr>           <chr>         <chr>        <list>    \n1         1 lm              regression    linear_reg   <spec[+]> \n2         2 gee             regression    linear_reg   <spec[+]> \n3         3 glm             regression    linear_reg   <spec[+]> \n```\n\n\n:::\n:::\n\nAs shown we can easily select the models we want either by choosing the supported parsnip function like linear_reg() or by choose the desired engine, you can also use them both in conjunction with each other!\n\nThis function also does add a class to the output. Let’s see it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(fast_regression_parsnip_spec_tbl())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"tidyaml_mod_spec_tbl\" \"fst_reg_spec_tbl\"     \"tidyaml_base_tbl\"    \n[4] \"tbl_df\"               \"tbl\"                  \"data.frame\"          \n```\n\n\n:::\n:::\n\nWe see that there are two added classes, first fst_reg_spec_tbl because this creates a set of non-tuning regression models and then tidyaml_mod_spec_tbl because this is a model specification tibble built with {tidyAML}\n\nNow, what if you want to create a non-tuning model spec without using the fast_regression_parsnip_spec_tbl() function. Well, you can. The function is called create_model_spec().\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreate_model_spec(\n .parsnip_eng = list(\"lm\",\"glm\",\"glmnet\",\"cubist\"),\n .parsnip_fns = list(\n      \"linear_reg\",\n      \"linear_reg\",\n      \"linear_reg\",\n      \"cubist_rules\"\n     )\n )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 4\n  .parsnip_engine .parsnip_mode .parsnip_fns .model_spec\n  <chr>           <chr>         <chr>        <list>     \n1 lm              regression    linear_reg   <spec[+]>  \n2 glm             regression    linear_reg   <spec[+]>  \n3 glmnet          regression    linear_reg   <spec[+]>  \n4 cubist          regression    cubist_rules <spec[+]>  \n```\n\n\n:::\n\n```{.r .cell-code}\ncreate_model_spec(\n .parsnip_eng = list(\"lm\",\"glm\",\"glmnet\",\"cubist\"),\n .parsnip_fns = list(\n      \"linear_reg\",\n      \"linear_reg\",\n      \"linear_reg\",\n      \"cubist_rules\"\n     ),\n .return_tibble = FALSE\n )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$.parsnip_engine\n$.parsnip_engine[[1]]\n[1] \"lm\"\n\n$.parsnip_engine[[2]]\n[1] \"glm\"\n\n$.parsnip_engine[[3]]\n[1] \"glmnet\"\n\n$.parsnip_engine[[4]]\n[1] \"cubist\"\n\n\n$.parsnip_mode\n$.parsnip_mode[[1]]\n[1] \"regression\"\n\n\n$.parsnip_fns\n$.parsnip_fns[[1]]\n[1] \"linear_reg\"\n\n$.parsnip_fns[[2]]\n[1] \"linear_reg\"\n\n$.parsnip_fns[[3]]\n[1] \"linear_reg\"\n\n$.parsnip_fns[[4]]\n[1] \"cubist_rules\"\n\n\n$.model_spec\n$.model_spec[[1]]\nLinear Regression Model Specification (regression)\n\nComputational engine: lm \n\n\n$.model_spec[[2]]\nLinear Regression Model Specification (regression)\n\nComputational engine: glm \n\n\n$.model_spec[[3]]\nLinear Regression Model Specification (regression)\n\nComputational engine: glmnet \n\n\n$.model_spec[[4]]\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n! parsnip could not locate an implementation for `cubist_rules` regression\n  model specifications using the `cubist` engine.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCubist Model Specification (regression)\n\nComputational engine: cubist \n```\n\n\n:::\n:::\n\nThe first example shows the output as a tibble, the second example shows the output as a list of model specs. The last one for cubist rules also shows how it will gracefully fail if the package is not loaded.\n\n---\n\nHappy Coding!",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}