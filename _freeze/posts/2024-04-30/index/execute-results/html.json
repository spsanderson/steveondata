{
  "hash": "e9f91c2faba5b124549a871ccf8ea318",
  "result": {
    "markdown": "---\ntitle: \"Quantile Normalization in R with the {TidyDensity} Package\"\nauthor: \"Steven P. Sanderson II, MPH\"\ndate: \"2024-04-30\"\ncategories: [code, rtip, tidydensity]\n---\n\n\n# Introduction\n\nIn data analysis, especially when dealing with multiple samples or distributions, ensuring comparability and removing biases is crucial. One powerful technique for achieving this is quantile normalization. This method aligns the distributions of values across different samples, making them more similar in terms of their statistical properties.\n\n# What is Quantile Normalization?\n\nQuantile normalization is a statistical method used to adjust the distributions of values in different datasets so that they have similar quantiles. This technique is particularly valuable when working with high-dimensional data, such as gene expression data or other omics datasets, where ensuring comparability across samples is essential.\n\n# Introducing `quantile_normalize()` in TidyDensity\n\nThe `quantile_normalize()` function is a new addition to the TidyDensity package, designed to simplify the process of quantile normalization within R. Let's delve into how this function works and how you can integrate it into your data analysis pipeline.\n\n# Function Usage\n\nThe `quantile_normalize()` function takes a numeric matrix as input, where each column represents a sample. Here's a breakdown of its usage:\n\n```R\nquantile_normalize(.data, .return_tibble = FALSE)\n```\n\n- `.data`: A numeric matrix where each column corresponds to a sample that requires quantile normalization.\n- `.return_tibble`: A logical value (default: `FALSE`) indicating whether the output should be returned as a tibble.\n\n# Understanding the Output\n\nWhen you apply `quantile_normalize()` to your data, you receive a list object containing the following components:\n\n1. **Quantile-Normalized Matrix**: A numeric matrix where each column has been quantile-normalized.\n2. **Row Means**: The means of each row across the quantile-normalized matrix.\n3. **Sorted Data**: The sorted values used during the quantile normalization process.\n4. **Ranked Indices**: The indices of the sorted values.\n\n# How Quantile Normalization Works\n\nThe `quantile_normalize()` function performs quantile normalization through the following steps:\n\n1. **Sorting**: Each column of the input matrix is sorted.\n2. **Row Mean Calculation**: The mean of each row across the sorted columns is computed.\n3. **Normalization**: Each column's sorted values are replaced with the corresponding row means.\n4. **Unsorting**: The columns are restored to their original order, ensuring that the quantile-normalized matrix maintains the same structure as the input.\n\n# Examples\n\nLet's demonstrate the usage of `quantile_normalize()` with a simple example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load TidyDensity\nlibrary(TidyDensity)\n\n# Create a sample matrix\nset.seed(123)\ndata <- matrix(rnorm(50), ncol = 4)\nhead(data, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            [,1]       [,2]       [,3]       [,4]\n[1,] -0.56047565  0.1106827  0.8377870 -0.3804710\n[2,] -0.23017749 -0.5558411  0.1533731 -0.6947070\n[3,]  1.55870831  1.7869131 -1.1381369 -0.2079173\n[4,]  0.07050839  0.4978505  1.2538149 -1.2653964\n[5,]  0.12928774 -1.9666172  0.4264642  2.1689560\n```\n:::\n\n```{.r .cell-code}\n# Apply quantile normalization\nresult <- quantile_normalize(data)\n\n# Access the quantile-normalized matrix\nnormalized_matrix <- result[[\"normalized_data\"]]\n\n# View the normalized matrix\nhead(normalized_matrix, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            [,1]       [,2]        [,3]       [,4]\n[1,] -0.65451945 -0.3180877  0.84500772 -0.6545195\n[2,] -0.06327669  0.8450077  1.09078797 -0.9506544\n[3,] -1.40880292 -0.5235134  0.33150422  0.0863713\n[4,]  0.84500772  1.0907880  0.08637130  0.1991151\n[5,] -0.31808774 -0.6545195 -0.06327669  0.3315042\n```\n:::\n:::\n\nLet's now look at the rest of the output components:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(result[[\"row_means\"]], 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1.4088029 -0.9506544 -0.6545195 -0.5235134 -0.3180877\n```\n:::\n\n```{.r .cell-code}\nhead(result[[\"duplicated_ranks\"]], 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    9   13   13    7\n[2,]   10   10   12   12\n[3,]    2   11    2    9\n[4,]   13    9    9    3\n[5,]    7    1    1   11\n```\n:::\n\n```{.r .cell-code}\nhead(result[[\"duplicated_rank_row_indicies\"]], 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n\n```{.r .cell-code}\nhead(result[[\"duplicated_rank_data\"]], 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            [,1]       [,2]      [,3]       [,4]\n[1,] -0.23017749 -0.5558411 0.1533731 -0.6947070\n[2,]  0.07050839  0.4978505 1.2538149 -1.2653964\n[3,]  0.12928774 -1.9666172 0.4264642  2.1689560\n[4,] -0.68685285 -0.2179749 0.8215811 -0.4666554\n[5,] -0.44566197 -1.0260044 0.6886403  0.7799651\n```\n:::\n:::\n\n\nNow, lets take a look at the before and after quantile normalization summary:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.data.frame(data) |>\n  sapply(function(x) quantile(x, probs = seq(0, 1, 1/4)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             V1         V2          V3          V4\n0%   -1.2650612 -1.9666172 -1.13813694 -1.26539635\n25%  -0.4456620 -1.0260044 -0.06191171 -0.56047565\n50%   0.1292877 -0.5558411  0.55391765 -0.38047100\n75%   0.4609162  0.1106827  0.83778704 -0.08336907\n100%  1.7150650  1.7869131  1.25381492  2.16895597\n```\n:::\n\n```{.r .cell-code}\nas.data.frame(normalized_matrix) |>\n  sapply(function(x) quantile(x, probs = seq(0, 1, 1/4)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n              V1          V2          V3          V4\n0%   -1.40880292 -1.40880292 -1.40880292 -1.40880292\n25%  -0.52351344 -0.52351344 -0.52351344 -0.52351344\n50%  -0.06327669 -0.06327669 -0.06327669 -0.06327669\n75%   0.33150422  0.33150422  0.33150422  0.33150422\n100%  1.73118725  1.73118725  1.73118725  1.73118725\n```\n:::\n:::\n\n\nNow let's use the `.return_tibble` argument to return the output as a tibble:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquantile_normalize(data, .return_tibble = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$normalized_data\n# A tibble: 13 × 4\n        V1      V2      V3      V4\n     <dbl>   <dbl>   <dbl>   <dbl>\n 1 -0.655  -0.318   0.845  -0.655 \n 2 -0.0633  0.845   1.09   -0.951 \n 3 -1.41   -0.524   0.332   0.0864\n 4  0.845   1.09    0.0864  0.199 \n 5 -0.318  -0.655  -0.0633  0.332 \n 6  1.73   -0.0633 -0.133  -0.133 \n 7 -0.524  -0.133  -0.524  -0.524 \n 8 -0.133   1.73    1.73    1.73  \n 9  0.332   0.0864  0.199   1.09  \n10  1.09   -0.951  -0.655  -0.318 \n11 -0.951  -1.41   -0.318  -1.41  \n12  0.199   0.199  -1.41    0.845 \n13  0.0864  0.332  -0.951  -0.0633\n\n$row_means\n# A tibble: 13 × 1\n     value\n     <dbl>\n 1 -1.41  \n 2 -0.951 \n 3 -0.655 \n 4 -0.524 \n 5 -0.318 \n 6 -0.133 \n 7 -0.0633\n 8  0.0864\n 9  0.199 \n10  0.332 \n11  0.845 \n12  1.09  \n13  1.73  \n\n$duplicated_ranks\n# A tibble: 6 × 4\n     V1    V2    V3    V4\n  <int> <int> <int> <int>\n1     9    13    13     7\n2    10    10    12    12\n3     2    11     2     9\n4    13     9     9     3\n5     7     1     1    11\n6     3     6     7     6\n\n$duplicated_rank_row_indices\n# A tibble: 6 × 1\n  row_index\n      <int>\n1         2\n2         4\n3         5\n4         9\n5        10\n6        12\n\n$duplicated_rank_data\n# A tibble: 6 × 4\n       V1     V2      V3     V4\n    <dbl>  <dbl>   <dbl>  <dbl>\n1 -0.230  -0.556  0.153  -0.695\n2  0.0705  0.498  1.25   -1.27 \n3  0.129  -1.97   0.426   2.17 \n4 -0.687  -0.218  0.822  -0.467\n5 -0.446  -1.03   0.689   0.780\n6  0.360  -0.625 -0.0619 -0.560\n```\n:::\n:::\n\n### Conclusion\n\nIn summary, the `quantile_normalize()` function from the TidyDensity package offers a convenient and efficient way to perform quantile normalization on numeric matrices in R. By leveraging this function, you can enhance the comparability and statistical integrity of your data across multiple samples or distributions. Incorporate `quantile_normalize()` into your data preprocessing workflow to unlock deeper insights and more robust analyses.\n\nTo explore more functionalities of TidyDensity and leverage its capabilities for advanced data analysis tasks, check out the package documentation and experiment with different parameters and options provided by the `quantile_normalize()` function.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}