{
  "hash": "732a54be2f55686358d5d174f1965ea0",
  "result": {
    "markdown": "---\ntitle: \"Mastering Quantile Normalization in R: A Step-by-Step Guide\"\nauthor: \"Steven P. Sanderson II, MPH\"\ndate: \"2024-03-28\"\ncategories: [code, rtip, operations]\n---\n\n\n# Introduction\n\nQuantile normalization is a crucial technique in data preprocessing, especially in fields like genomics and bioinformatics. It ensures that the distributions of different samples are aligned, making them directly comparable. In this tutorial, we'll walk through the process step by step, demystifying the syntax and empowering you to apply this technique confidently in your projects.\n\n# Understanding Quantile Normalization\n\nBefore we dive into the code, let's understand the concept behind quantile normalization. At its core, quantile normalization aims to equalize the distributions of multiple datasets by aligning their quantiles. This ensures that each dataset has the same distribution of values, making meaningful comparisons possible.\n\n# Example\n\n## Step 1: Load Your Data\n\nFirst things first, you'll need some data to work with. For the sake of this tutorial, let's say you have a dataframe called `df` containing your datasets.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(42)  # For reproducibility\ndf <- data.frame(\n  sample1 = rnorm(100, mean = 5, sd = 2),\n  sample2 = rnorm(100, mean = 10, sd = 1),\n  sample3 = rnorm(100)\n)\n\nhead(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   sample1   sample2    sample3\n1 7.741917 11.200965 -2.0009292\n2 3.870604 11.044751  0.3337772\n3 5.726257  8.996791  1.1713251\n4 6.265725 11.848482  2.0595392\n5 5.808537  9.333227 -1.3768616\n6 4.787751 10.105514 -1.1508556\n```\n:::\n\n```{.r .cell-code}\nhist(df$sample1, col = 'red', xlim=c(min(df), max(df)), \n     main = 'Distribution of Sample 1')\nhist(df$sample2, col = 'blue', add = TRUE)\nhist(df$sample3, col = 'green', add = TRUE)\n#add legend\nlegend('topright', \n       c('Sample 1', 'Sample 2','Sample 3'), \n       fill=c('red','blue', 'green'))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\n## Step 2: Perform Quantile Normalization\n\nNow, it's time to perform quantile normalization using R's built-in `quantile()` function. This function calculates quantiles for a given dataset, which is essential for aligning the distributions. Function from: https://lifewithdata.com/2023/09/02/how-to-perform-quantile-normalization-in-r/\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Perform quantile normalization\nqn <- function(.data){\n data_sort <- apply(.data, 2, sort)\n row_means <- rowMeans(data_sort)\n data_sort <- matrix(row_means, \n                     nrow = nrow(data_sort), \n                     ncol = ncol(data_sort), \n                     byrow = TRUE\n                     )\n index_rank <- apply(.data, 2, order)\n normalized_data <- matrix(nrow = nrow(.data), ncol = ncol(.data))\n for(i in 1:ncol(.data)){\n   normalized_data[,i] <- data_sort[index_rank[,i], i]\n }\n return(normalized_data)\n}\n\nnormalized_data <- qn(df)\n```\n:::\n\n\nLet's break down this code snippet:\n\nAbsolutely, let's break down this R code block piece by piece:\n\n**1. Function Definition:**\n\n```r\nqn <- function(.data){\n  # ... function body here ...\n}\n```\n\nThis defines a function named `qn` that takes a data frame (`data`) as input. This data frame is most likely your dataset you want to normalize.\n\n**2. Sorting Each Column:**\n\n```r\ndata_sort <- apply(.data, 2, sort)\n```\n\nThis line sorts each column of the data frame `data` independently. Imagine sorting rows of data like sorting words in a dictionary. Here, we are sorting each column (each variable) from smallest to largest values. The result is stored in `data_sort`.\n\n**3. Calculating Row Means:**\n\n```r\nrow_means <- rowMeans(data_sort)\n```\n\nThis line calculates the average value for each row in the sorted data frame (`data_sort`). So, for each row (each data point), it finds the mean of the sorted values across all variables. The result is stored in `row_means`.\n\n**4. Replicating Row Means into a Matrix:**\n\n```r\ndata_sort <- matrix(row_means, \n                    nrow = nrow(data_sort), \n                    ncol = ncol(data_sort), \n                    byrow = TRUE\n                    )\n```\n\nThis part is a bit trickier. It creates a new matrix (`data_sort`) with the same dimensions (number of rows and columns) as the original sorted data. Then, it fills each row of this new matrix with the corresponding row mean calculated earlier (`row_means`). The `byrow` argument ensures this replication happens row-wise.\n\n**5. Ranking Each Value's Position:**\n\n```r\nindex_rank <- apply(.data, 2, order)\n```\n\nSimilar to sorting, this line assigns a rank (position) to each value within its column (variable) in the original data frame (`data`). Imagine a race where the first place gets rank 1, second place gets rank 2, and so on. Here, the rank indicates the original position of each value after everything was sorted in step 2. The result is stored in `index_rank`.\n\n**6. Building the Normalized Data Frame:**\n\n```r\nnormalized_data <- matrix(nrow = nrow(.data), ncol = ncol(.data))\n```\n\nThis line creates an empty matrix (`normalized_data`) with the same dimensions as the original data frame. This will eventually hold the normalized data.\n\n**7. Looping Through Columns and Assigning Ranked Values:**\n\n```r\nfor(i in 1:ncol(.data)){\n  normalized_data[,i] <- data_sort[index_rank[,i], i]\n}\n```\n\nThis is the core of the normalization process. It loops through each column (variable) of the original data frame (`data`). For each column, it uses the ranks (`index_rank`) as indices to pick values from the sorted data with row means (`data_sort`). Basically, it replaces each value in the original data with the value from the sorted data that has the same rank (original position). This effectively replaces the original values with their corresponding row means (representing the center point) based on their original order.\n\n**8. Returning the Normalized Data:**\n\n```r\nreturn(normalized_data)\n```\n\nFinally, the function returns the `normalized_data` matrix, which contains the quantile normalized version of your original data frame.\n\nIn essence, this code performs a type of rank-based normalization where each value is replaced with the row mean that corresponds to its original position after sorting all the data together. This approach ensures that the distribution of values across columns becomes more consistent.\n\n## Step 3: Explore the Results\n\nAfter quantile normalization, you'll have a list of normalized datasets ready for further analysis. Take a moment to explore the results and ensure that the distributions are aligned as expected.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    sample1           sample2          sample3        \n Min.   :-0.9862   Min.   : 7.975   Min.   :-2.69993  \n 1st Qu.: 3.7666   1st Qu.: 9.409   1st Qu.:-0.71167  \n Median : 5.1796   Median : 9.931   Median :-0.02474  \n Mean   : 5.0650   Mean   : 9.913   Mean   :-0.01037  \n 3rd Qu.: 6.3231   3rd Qu.:10.462   3rd Qu.: 0.65254  \n Max.   : 9.5733   Max.   :12.702   Max.   : 2.45959  \n```\n:::\n\n```{.r .cell-code}\n# Explore the results\nsummary(normalized_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       V1              V2              V3       \n Min.   :1.430   Min.   :1.430   Min.   :1.430  \n 1st Qu.:4.154   1st Qu.:4.154   1st Qu.:4.154  \n Median :5.029   Median :5.029   Median :5.029  \n Mean   :4.989   Mean   :4.989   Mean   :4.989  \n 3rd Qu.:5.812   3rd Qu.:5.812   3rd Qu.:5.812  \n Max.   :8.245   Max.   :8.245   Max.   :8.245  \n```\n:::\n:::\n\n\n## Step 4: Obtain Quantiles\n\nNow that the data is normalized, we can extract the quantiles to compare the distributions across datasets. This will help you confirm that the normalization process was successful.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.data.frame(normalized_data) |> \n  sapply(function(x) quantile(x, probs = seq(0,1,1/4)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           V1       V2       V3\n0%   1.429737 1.429737 1.429737\n25%  4.154481 4.154481 4.154481\n50%  5.028521 5.028521 5.028521\n75%  5.812480 5.812480 5.812480\n100% 8.244925 8.244925 8.244925\n```\n:::\n:::\n\n\nAs we can see, the quantiles of the normalized data are consistent across the different datasets. This indicates that the distributions have been aligned through quantile normalization.\n\nLet's visuzlize for another confirmation\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_normalized <- as.data.frame(normalized_data)\n\nhist(df_normalized$V1, col = 'red')\nhist(df_normalized$V2, col = 'blue', add = TRUE)\nhist(df_normalized$V3, col = 'green', add = TRUE)\n\nlegend('topright', c('Sample 1', 'Sample 2','Sample 3'), fill=c('red','blue', 'green'))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n# Wrapping Up\n\nCongratulations! You've successfully mastered quantile normalization in R. By understanding the underlying concept and applying the `quantile()` function effectively, you can ensure that your datasets are comparable and ready for downstream analysis.\n\nI encourage you to experiment with different datasets and explore the impact of quantile normalization on your analyses. Remember, practice makes perfect, so don't hesitate to try it out on your own data. Happy coding!",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}